<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RNG Item Collector V4 - Anomalies & Crafting</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css"
    />
    <!-- Updated FontAwesome -->
    <style>
      :root {
           --rarity-common-color: #576a81; --rarity-common-border: #9cb1cc; --rarity-common-bg: #f1f5f9;
           --rarity-uncommon-color: #059669; --rarity-uncommon-border: #34d399; --rarity-uncommon-bg: #d1fae5;
           --rarity-rare-color: #2563eb; --rarity-rare-border: #60a5fa; --rarity-rare-bg: #dbeafe;
           --rarity-epic-color: #9333ea; --rarity-epic-border: #c084fc; --rarity-epic-bg: #f3e8ff;
           --rarity-legendary-color: #d97706; --rarity-legendary-border: #fbbf24; --rarity-legendary-bg: #fef3c7;
           --rarity-mythic-color: #dc2626; --rarity-mythic-border: #f87171; --rarity-mythic-bg: #fee2e2;
           --ascended-color: #c026d3; /* Fuchsia for ascended items */
           --ascended-border: #f0abfc;
           --ascended-bg: #fae8ff;
      }

      body { font-family: 'Inter', sans-serif; background-color: #f8fafc; /* Near white background */ color: #1f2937; }

      /* Rarity Styles using CSS Variables */
      .rarity-Common { color: var(--rarity-common-color); border-color: var(--rarity-common-border); }
      .bg-rarity-Common { background-color: var(--rarity-common-bg); }
      .rarity-Uncommon { color: var(--rarity-uncommon-color); border-color: var(--rarity-uncommon-border); }
      .bg-rarity-Uncommon { background-color: var(--rarity-uncommon-bg); }
      .rarity-Rare { color: var(--rarity-rare-color); border-color: var(--rarity-rare-border); }
      .bg-rarity-Rare { background-color: var(--rarity-rare-bg); }
      .rarity-Epic { color: var(--rarity-epic-color); border-color: var(--rarity-epic-border); }
      .bg-rarity-Epic { background-color: var(--rarity-epic-bg); }
      .rarity-Legendary { color: var(--rarity-legendary-color); border-color: var(--rarity-legendary-border); }
      .bg-rarity-Legendary { background-color: var(--rarity-legendary-bg); }
      .rarity-Mythic { color: var(--rarity-mythic-color); border-color: var(--rarity-mythic-border); }
      .bg-rarity-Mythic { background-color: var(--rarity-mythic-bg); }
      .rarity-Ascended { color: var(--ascended-color); border-color: var(--ascended-border); } /* Added Ascended style */
      .bg-rarity-Ascended { background-color: var(--ascended-bg); }


      /* Smooth transitions */
      .transition-all { transition: all 0.3s ease-in-out; }
      .transition-color { transition: color 0.3s ease-in-out, background-color 0.3s ease-in-out, border-color 0.3s ease-in-out; }
      .transition-opacity { transition: opacity 0.3s ease-in-out; }
      .transition-transform { transition: transform 0.3s ease-in-out; }

      /* Base Button & Roll Button (no major changes needed) */
      .btn { padding: 0.6rem 1.2rem; border-radius: 0.375rem; font-weight: 600; transition: all 0.2s ease; text-align: center; cursor: pointer; border: 1px solid transparent; box-shadow:sm }
      .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; box-shadow: none !important;}
      .btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
      .btn:active:not(:disabled) { transform: translateY(0px); box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); }
      .btn-primary { background-color: #4f46e5; color: white; border-color: #4f46e5; } .btn-primary:hover:not(:disabled) { background-color: #4338ca; }
      .btn-success { background-color: #10b981; color: white; border-color: #10b981; } .btn-success:hover:not(:disabled) { background-color: #059669; }
      .btn-warning { background-color: #f59e0b; color: white; border-color: #f59e0b; } .btn-warning:hover:not(:disabled) { background-color: #d97706; }
      .btn-danger { background-color: #ef4444; color: white; border-color: #ef4444; } .btn-danger:hover:not(:disabled) { background-color: #dc2626; }
      .btn-outline-gray { border: 1px solid #d1d5db; color: #4b5563; } .btn-outline-gray:hover:not(:disabled) { background-color: #f3f4f6; }
      .btn-xs { padding: 0.2rem 0.5rem; font-size: 0.75rem; border-radius: 0.25rem; line-height: 1.2; font-weight: 500;}

      .roll-button { background: linear-gradient(145deg, #4f46e5, #7c3aed); transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); color: white; font-weight: bold; border-radius: 9999px; padding: 0.75rem 2rem; text-align: center; font-size: 1.125rem;}
      .roll-button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15); background: linear-gradient(145deg, #5a50e6, #8b4bf0); }
      .roll-button:active:not(:disabled) { transform: translateY(0px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
      .roll-button:disabled { opacity: 0.5; cursor: not-allowed; background: #9ca3af; box-shadow: none; transform: none !important; }
      .guaranteed-roll-button { background: linear-gradient(145deg, #f59e0b, #ef4444); } .guaranteed-roll-button:hover:not(:disabled) { background: linear-gradient(145deg, #fbbd23, #f87171); }

      /* Scrollbar styling */
      .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
      .custom-scrollbar::-webkit-scrollbar-track { background: #e5e7eb; border-radius: 10px; }
      .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #9ca3af; border-radius: 10px; border: 2px solid #e5e7eb; }
      .custom-scrollbar::-webkit-scrollbar-thumb:hover { background-color: #6b7280; }

      /* Achievement & Set Styling (no changes) */
      .achievement-locked, .set-incomplete { opacity: 0.7; filter: grayscale(60%); transition: all 0.3s ease;}
      .achievement-unlocked, .set-complete { border-left: 4px solid #10b981; transition: all 0.3s ease;}
      .set-complete { border-left-color: #fbbf24; }

      /* Toast Notification */
      #toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 20px; color: white; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); z-index: 1000; opacity: 0; transition: opacity 0.5s ease-in-out, bottom 0.5s ease-in-out, background-color 0.3s ease; font-weight: 500; text-align: center;}
      #toast.show { opacity: 1; bottom: 40px; }
      #toast.info { background-color: #3b82f6; } /* blue-500 */
      #toast.success { background-color: #22c55e; } /* green-500 */
      #toast.error { background-color: #ef4444; } /* red-500 */
      #toast.warning { background-color: #f59e0b; } /* amber-500 */
      #toast.anomaly { background: linear-gradient(135deg, #6366f1, #a855f7); font-weight: bold; } /* Indigo to purple gradient for anomalies */

      /* Tab Styling (no changes) */
      .tab-button { padding: 8px 16px; font-weight: 500; color: #4b5563; border-bottom: 2px solid transparent; cursor: pointer; transition: all 0.2s ease; white-space: nowrap;}
      .tab-button:hover { color: #1f2937; border-bottom-color: #d1d5db; }
      .tab-button.active { color: #4f46e5; border-bottom-color: #4f46e5; font-weight: 600; }
      .tab-content { display: none; padding-top: 1.5rem; animation: fadeIn 0.5s ease; }
      .tab-content.active { display: block; }
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

      /* Progress Bar (no changes) */
      .progress-bar-bg { background-color: #e5e7eb; border-radius: 9999px; overflow: hidden; height: 8px; }
      .progress-bar-fill { background-color: #4ade80; height: 100%; transition: width 0.3s ease-in-out; border-radius: 9999px; }

      /* Infusion Highlight (no changes) */
      .infuse-selected { background-color: #dbeafe !important; box-shadow: 0 0 0 2px #60a5fa; }
      .infuse-item-entry { transition: background-color 0.2s ease; border-radius: 4px; }

      /* Inventory Item actions on hover */
      .inventory-item .inventory-item-actions { opacity: 0; transition: opacity 0.2s ease-in-out; pointer-events: none; }
      .inventory-item:hover .inventory-item-actions { opacity: 1; pointer-events: auto; }

      /* Result Animations & Feedback */
      @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
      @keyframes rare-item-celebration {
           0% { transform: scale(1); box-shadow: none; }
           25% { transform: scale(1.1); } /* Quick pop */
           50% { transform: scale(1.05); }
           100% { transform: scale(1); }
      }
       @keyframes shake {
         10%, 90% { transform: translate3d(-1px, 0, 0); }
         20%, 80% { transform: translate3d(2px, 0, 0); }
         30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
         40%, 60% { transform: translate3d(4px, 0, 0); }
       }
      /* Glows */
      @keyframes glow-rare { 0%, 100% { box-shadow: 0 0 10px 3px rgba(96, 165, 250, 0.8); } 50% { box-shadow: 0 0 20px 7px rgba(96, 165, 250, 1); } }
      @keyframes glow-epic { 0%, 100% { box-shadow: 0 0 12px 4px rgba(192, 132, 252, 0.8); } 50% { box-shadow: 0 0 24px 9px rgba(192, 132, 252, 1); } }
      @keyframes glow-legendary { 0%, 100% { box-shadow: 0 0 14px 5px rgba(251, 191, 36, 0.8); } 50% { box-shadow: 0 0 28px 11px rgba(251, 191, 36, 1); } }
      @keyframes glow-mythic { 0%, 100% { box-shadow: 0 0 16px 6px rgba(248, 113, 113, 0.9); } 50% { box-shadow: 0 0 32px 13px rgba(248, 113, 113, 1); } }
      .animate-pulse-quick { animation: pulse 0.5s ease-in-out 1; }
       .animate-celebrate-rare { animation: rare-item-celebration 0.6s ease-in-out 1, glow-rare 1.5s ease-in-out infinite; }
       .animate-celebrate-epic { animation: rare-item-celebration 0.7s ease-in-out 1, glow-epic 1.3s ease-in-out infinite; }
       .animate-celebrate-legendary { animation: rare-item-celebration 0.8s ease-in-out 1, glow-legendary 1.1s ease-in-out infinite; }
       .animate-celebrate-mythic { animation: rare-item-celebration 0.9s ease-in-out 1, glow-mythic 0.9s ease-in-out infinite; }
      .animate-shake { animation: shake 0.6s cubic-bezier(.36,.07,.19,.97) both; }


      /* Tooltip Styling (no changes) */
      [data-tooltip] { position: relative; cursor: help; }
      [data-tooltip]::after { content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(-5px); background-color: #374151; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; line-height: 1.2; white-space: nowrap; z-index: 10; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; }
      [data-tooltip]:hover::after { opacity: 1; visibility: visible; transition-delay: 0.5s;}

      /* Small Icons for item effects / anomalies */
      .effect-icon { font-size: 0.7em; vertical-align: super; margin-left: 2px; cursor: help; }
      .anomaly-icon { display: inline-block; padding: 2px 6px; border-radius: 99px; font-size: 0.75rem; font-weight: 500; margin: 2px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); animation: fadeIn 0.5s ease; cursor: help; }
      .anomaly-good { background-color: #dcfce7; color: #166534; border: 1px solid #86efac; }
      .anomaly-bad { background-color: #fee2e2; color: #991b1b; border: 1px solid #fca5a5; }
      .anomaly-neutral { background-color: #dbeafe; color: #1e40af; border: 1px solid #93c5fd; }

      /* Crafting Styles */
      .recipe { border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 1rem; background-color: #f9fafb; transition: all 0.2s ease; }
      .recipe.can-craft { border-color: var(--rarity-uncommon-border); background-color: var(--rarity-uncommon-bg); }
      .recipe:hover { box-shadow: 0 4px 6px rgba(0,0,0,0.05); }
      .recipe-item { font-size: 0.8rem; padding: 2px 6px; border-radius: 4px; margin: 2px 0; display: inline-block; border: 1px solid; }
      .recipe-item.missing { opacity: 0.6; background-color: #fecaca !important; color: #b91c1c !important; border-color: #f87171 !important; }


      /* Responsive adjustments */
       @media (max-width: 640px) {
          .header-stats > div { padding: 4px 6px; }
          .header-stats .text-lg { font-size: 1rem;}
          .header-stats .text-sm { font-size: 0.75rem;}
          .header-stats .progress-bar-bg { width: 6rem; }
          .tab-button { padding: 6px 10px; font-size: 0.875rem; }
      }
    </style>
  </head>
  <body class="bg-gray-50 min-h-screen flex flex-col items-center p-2 md:p-6">
    <div
      class="w-full max-w-7xl bg-white rounded-xl shadow-lg p-4 md:p-8 space-y-5"
    >
      <header
        class="flex flex-col sm:flex-row justify-between items-center border-b pb-4 border-gray-200 gap-3"
      >
        <div>
          <h1
            class="text-2xl sm:text-3xl md:text-4xl font-bold text-gray-800 text-center sm:text-left"
          >
            RNG Collector <span class="text-indigo-500">V4</span>
          </h1>
          <p
            class="text-gray-500 mt-1 text-center sm:text-left text-sm sm:text-base"
          >
            Anomalies, Crafting, and Shiny Things!
          </p>
        </div>
        <!-- Player Stats moved slightly -->
        <div
          class="flex flex-col items-center sm:items-end space-y-2 w-full sm:w-auto"
        >
          <div
            class="flex flex-wrap items-center justify-center sm:justify-end space-x-2 sm:space-x-3 header-stats"
          >
            <!-- Level & XP -->
            <div
              class="text-right flex items-center space-x-2 bg-green-50 px-3 py-1 rounded-lg shadow-sm border border-green-200"
              data-tooltip="Player Level & Experience"
            >
              <i class="fa-solid fa-arrow-up-right-dots text-green-600"></i>
              <div>
                <div class="text-xs text-gray-500 leading-tight">
                  Level
                  <span
                    id="playerLevel"
                    class="font-bold text-lg text-green-700"
                    >1</span
                  >
                </div>
                <div class="w-24 mt-0.5 progress-bar-bg">
                  <div
                    id="playerXPBar"
                    class="progress-bar-fill !bg-green-500"
                    style="width: 0%;"
                  ></div>
                </div>
                <div class="text-xs text-gray-500 leading-tight">
                  <span id="playerXP">0</span>/<span id="xpToNextLevel"
                    >100</span
                  >
                  XP
                </div>
              </div>
            </div>
            <!-- Shards -->
            <div
              class="text-right bg-amber-100 px-3 py-1.5 rounded-lg shadow-sm border border-amber-200 flex items-center space-x-1.5"
              data-tooltip="Shards (Crafting/Infusion Currency)"
            >
              <span class="text-lg font-bold text-amber-700" id="playerShards"
                >0</span
              >
              <span class="text-xl text-amber-600">âœ¨</span>
            </div>
            <!-- Essence (Prestige Currency) -->
            <div
              class="text-right bg-purple-100 px-3 py-1.5 rounded-lg shadow-sm border border-purple-200 flex items-center space-x-1.5 hidden"
              id="essenceDisplay"
              data-tooltip="Ascension Essence (Prestige Currency)"
            >
              <span class="text-lg font-bold text-purple-700" id="playerEssence"
                >0</span
              >
              <span class="text-xl text-purple-600">ğŸŒŒ</span>
              <!-- Galaxy/Nebula icon -->
            </div>
          </div>
          <!-- Active Anomalies Display -->
          <div id="anomalyStatus" class="text-right mt-1 h-6">
            <!-- Anomalies will be added here -->
          </div>
        </div>
      </header>

      <!-- Tab Navigation -->
      <nav
        class="flex border-b border-gray-200 overflow-x-auto custom-scrollbar pb-0 -mb-px"
      >
        <button class="tab-button active" data-tab="roll">Roll</button>
        <button class="tab-button" data-tab="collection">Collection</button>
        <button class="tab-button" data-tab="crafting">Crafting</button>
        <!-- New Crafting Tab -->
        <button class="tab-button" data-tab="infuse">Infuse</button>
        <button class="tab-button" data-tab="sets">Sets</button>
        <button class="tab-button" data-tab="achievements">Achievements</button>
        <button class="tab-button" data-tab="stats">Stats</button>
        <button class="tab-button hidden" data-tab="ascension">
          Ascension
        </button>
        <!-- Hidden until unlocked -->
      </nav>

      <main>
        <!-- Roll Tab -->
        <section id="tabContent-roll" class="tab-content active">
          <div class="grid grid-cols-1 md:grid-cols-3 gap-6 items-start">
            <div
              class="md:col-span-1 flex flex-col items-center space-y-4 p-6 bg-gradient-to-br from-white to-gray-100 rounded-lg shadow-inner border border-gray-200"
            >
              <h2 class="text-xl font-semibold text-gray-700 self-start mb-2">
                Get New Item
              </h2>
              <button
                id="rollButton"
                class="roll-button w-full relative overflow-hidden"
              >
                Roll!
                <span
                  id="rollCostDisplay"
                  class="absolute bottom-1 right-3 text-xs opacity-70"
                ></span>
              </button>
              <button
                id="guaranteedRollButton"
                class="roll-button guaranteed-roll-button w-full mt-2 hidden"
              >
                Roll Rare+ (0 Left)
              </button>
              <p class="text-xs text-gray-500 mt-2 text-center">
                Rolling may trigger anomalies!
              </p>
            </div>
            <div
              class="md:col-span-2 p-6 bg-gray-100 rounded-lg shadow-inner border border-gray-200"
            >
              <h2 class="text-xl font-semibold text-gray-700 mb-3">
                Last Roll Result
              </h2>
              <div
                id="resultDisplayWrapper"
                class="w-full transition-transform duration-100"
              >
                <div
                  id="resultDisplay"
                  class="p-5 border border-gray-300 rounded-lg bg-white shadow-md w-full text-center min-h-[180px] flex flex-col justify-center items-center transition-all duration-300"
                >
                  <p class="text-gray-500 italic">Click 'Roll!' to start</p>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Collection Tab -->
        <section id="tabContent-collection" class="tab-content">
          <h2 class="text-xl font-semibold text-gray-700 mb-4">
            My Collection
            <i class="fa-solid fa-boxes-stacked text-indigo-500"></i>
          </h2>
          <!-- Sorting/Filtering UI (no changes from V3) -->
          <div
            class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-3 gap-2 text-sm"
          >
            <div class="flex items-center gap-2 flex-wrap">
              <label for="inventorySort" class="mr-1 text-gray-600 font-medium"
                >Sort:</label
              >
              <select
                id="inventorySort"
                class="border border-gray-300 rounded px-2 py-1 text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
              >
                <option value="rarity_desc">Rarity (Desc)</option>
                <option value="rarity">Rarity (Asc)</option>
                <option value="name">Name (A-Z)</option>
                <option value="count">Count</option>
                <option value="level">Infusion Lvl</option>
              </select>
              <label
                for="inventoryFilter"
                class="ml-2 mr-1 text-gray-600 font-medium"
                >Filter:</label
              >
              <select
                id="inventoryFilter"
                class="border border-gray-300 rounded px-2 py-1 text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
              >
                <option value="all">All Rarities</option>
                <!-- Options added dynamically -->
                <option value="has_effect">Has Effect</option>
                <!-- New filter -->
              </select>
            </div>
            <p
              id="inventoryCount"
              class="text-sm text-gray-600 font-medium text-right mt-2 sm:mt-0 whitespace-nowrap"
            >
              Unique: 0 | Total: 0
            </p>
          </div>
          <!-- Inventory List Area -->
          <div
            id="inventoryList"
            class="space-y-1.5 max-h-[500px] overflow-y-auto pr-2 custom-scrollbar border-t border-gray-200 pt-2"
          >
            <p
              id="emptyInventory"
              class="text-gray-500 italic py-4 text-center"
            >
              Your collection is empty.
            </p>
          </div>
        </section>

        <!-- Crafting Tab -->
        <section id="tabContent-crafting" class="tab-content">
          <h2 class="text-xl font-semibold text-gray-700 mb-4">
            Crafting <i class="fa-solid fa-hammer text-orange-600"></i>
          </h2>
          <p class="text-sm text-gray-600 mb-4">
            Combine your collected items into something new! Recipes unlock
            automatically.
          </p>
          <div
            id="recipeList"
            class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-h-[450px] overflow-y-auto pr-2 custom-scrollbar"
          >
            <p id="loadingRecipes" class="text-gray-500 italic">
              Loading recipes...
            </p>
            <!-- Recipes will be populated here -->
          </div>
        </section>

        <!-- Infuse Tab -->
        <section id="tabContent-infuse" class="tab-content">
          <!-- Infuse UI (Mostly unchanged from V3, just visual tweaks perhaps) -->
          <h2 class="text-xl font-semibold text-gray-700 mb-4">
            Infuse Item <i class="fa-solid fa-fire-alt text-red-500"></i>
          </h2>
          <p class="text-sm text-gray-600 mb-4">
            Select an item to increase its Infusion Level using Shards. Higher
            levels increase sell value significantly.
          </p>
          <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="md:col-span-1">
              <h3 class="text-lg font-medium text-gray-600 mb-2">
                Your Infusable Items
              </h3>
              <div
                id="infuseSelectionList"
                class="space-y-1.5 max-h-[450px] overflow-y-auto pr-2 border rounded-md p-2 bg-gray-50 custom-scrollbar"
              >
                <p
                  id="emptyInfuseList"
                  class="text-gray-500 italic py-4 text-center"
                >
                  No items available.
                </p>
              </div>
            </div>
            <div
              class="md:col-span-2 p-6 bg-indigo-50 rounded-lg shadow-inner border border-indigo-100 min-h-[350px] flex flex-col justify-between items-center"
            >
              <div id="infusionDetails" class="text-center w-full">
                <p class="text-gray-500 italic text-lg">Select an item</p>
              </div>
              <button
                id="infuseItemButton"
                class="btn btn-primary mt-6 w-full max-w-xs hidden"
                disabled
              >
                Infuse <span id="infuseButtonCost"></span> âœ¨
              </button>
            </div>
          </div>
        </section>

        <!-- Sets Tab -->
        <section id="tabContent-sets" class="tab-content">
          <!-- Sets UI (Mostly unchanged from V3, formatting consistency) -->
          <h2 class="text-xl font-semibold text-gray-700 mb-4">
            Collection Sets
            <i class="fa-solid fa-layer-group text-teal-600"></i>
          </h2>
          <p class="text-sm text-gray-600 mb-4">
            Complete sets for permanent bonuses. Bonuses stack!
          </p>
          <div
            id="setList"
            class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-h-[450px] overflow-y-auto pr-2 custom-scrollbar"
          >
            <p id="loadingSets" class="text-gray-500 italic">Loading sets...</p>
          </div>
        </section>

        <!-- Achievements Tab -->
        <section id="tabContent-achievements" class="tab-content">
          <!-- Achievements UI (Mostly unchanged from V3) -->
          <h2 class="text-xl font-semibold text-gray-700 mb-4">
            Achievements <i class="fa-solid fa-trophy text-yellow-500"></i>
          </h2>
          <p class="text-sm text-gray-600 mb-4">
            Unlock achievements for rewards like Shards, XP, and Guaranteed
            Rolls!
          </p>
          <div
            id="achievementList"
            class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-h-[450px] overflow-y-auto pr-2 custom-scrollbar"
          >
            <p id="loadingAchievements" class="text-gray-500 italic">
              Loading achievements...
            </p>
          </div>
        </section>

        <!-- Stats Tab -->
        <section id="tabContent-stats" class="tab-content">
          <!-- Stats UI (Added Ascended stat block) -->
          <h2 class="text-xl font-semibold text-gray-700 mb-4">
            Statistics <i class="fa-solid fa-chart-line text-blue-500"></i>
          </h2>
          <div
            class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4 text-sm bg-gray-50 p-4 rounded-lg border"
          >
            <!-- Main Stats -->
            <div
              class="flex items-center space-x-2 p-3 bg-indigo-100 rounded-md shadow-sm"
            >
              <i class="fa-solid fa-dice fa-lg text-indigo-600"></i>
              <div>
                <div class="text-indigo-800">Total Rolls</div>
                <span
                  id="totalRollsStat"
                  class="font-bold text-indigo-900 text-lg"
                  >0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 bg-green-100 rounded-md shadow-sm"
            >
              <i class="fa-solid fa-layer-group fa-lg text-green-600"></i>
              <div>
                <div class="text-green-800">Sets Completed</div>
                <span
                  id="completedSetsStat"
                  class="font-bold text-green-900 text-lg"
                  >0/0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 bg-yellow-100 rounded-md shadow-sm"
            >
              <i class="fa-solid fa-trophy fa-lg text-yellow-600"></i>
              <div>
                <div class="text-yellow-800">Achievements</div>
                <span
                  id="achievementsUnlockedStat"
                  class="font-bold text-yellow-900 text-lg"
                  >0/0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 bg-orange-100 rounded-md shadow-sm"
            >
              <i class="fa-solid fa-fire-alt fa-lg text-orange-600"></i>
              <div>
                <div class="text-orange-800">Max Infusion Lvl</div>
                <span
                  id="maxInfusionStat"
                  class="font-bold text-orange-900 text-lg"
                  >0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 bg-purple-100 rounded-md shadow-sm"
            >
              <i class="fa-solid fa-sack-dollar fa-lg text-purple-600"></i>
              <div>
                <div class="text-purple-800">Total Shards Earned</div>
                <span
                  id="totalShardsEarnedStat"
                  class="font-bold text-purple-900 text-lg"
                  >0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 bg-pink-100 rounded-md shadow-sm"
            >
              <i class="fa-solid fa-recycle fa-lg text-pink-600"></i>
              <div>
                <div class="text-pink-800">Items Crafted</div>
                <span
                  id="itemsCraftedStat"
                  class="font-bold text-pink-900 text-lg"
                  >0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 bg-red-100 rounded-md shadow-sm"
            >
              <i class="fa-solid fa-bolt fa-lg text-red-600"></i>
              <div>
                <div class="text-red-800">Anomalies Encountered</div>
                <span
                  id="anomaliesEncounteredStat"
                  class="font-bold text-red-900 text-lg"
                  >0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 bg-fuchsia-100 rounded-md shadow-sm"
            >
              <i class="fa-solid fa-star fa-lg text-fuchsia-600"></i>
              <div>
                <div class="text-fuchsia-800">Total Essence Earned</div>
                <span
                  id="totalEssenceEarnedStat"
                  class="font-bold text-fuchsia-900 text-lg"
                  >0</span
                >
              </div>
            </div>

            <!-- Rarity Stats -->
            <div
              class="flex items-center space-x-2 p-3 rarity-Common border rounded-md shadow-sm"
            >
              <i class="fa-solid fa-circle fa-xs"></i>
              <div>
                <div class="text-gray-600">Common Rolled</div>
                <span id="commonStat" class="font-bold text-gray-800 text-lg"
                  >0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 rarity-Uncommon border rounded-md shadow-sm"
            >
              <i class="fa-solid fa-circle fa-xs"></i>
              <div>
                <div class="text-green-700">Uncommon Rolled</div>
                <span id="uncommonStat" class="font-bold text-green-900 text-lg"
                  >0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 rarity-Rare border rounded-md shadow-sm"
            >
              <i class="fa-solid fa-circle fa-xs"></i>
              <div>
                <div class="text-blue-700">Rare Rolled</div>
                <span id="rareStat" class="font-bold text-blue-900 text-lg"
                  >0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 rarity-Epic border rounded-md shadow-sm"
            >
              <i class="fa-solid fa-circle fa-xs"></i>
              <div>
                <div class="text-purple-700">Epic Rolled</div>
                <span id="epicStat" class="font-bold text-purple-900 text-lg"
                  >0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 rarity-Legendary border rounded-md shadow-sm"
            >
              <i class="fa-solid fa-circle fa-xs"></i>
              <div>
                <div class="text-orange-700">Legendary Rolled</div>
                <span
                  id="legendaryStat"
                  class="font-bold text-orange-900 text-lg"
                  >0</span
                >
              </div>
            </div>
            <div
              class="flex items-center space-x-2 p-3 rarity-Mythic border rounded-md shadow-sm"
            >
              <i class="fa-solid fa-circle fa-xs"></i>
              <div>
                <div class="text-red-700">Mythic Rolled</div>
                <span id="mythicStat" class="font-bold text-red-900 text-lg"
                  >0</span
                >
              </div>
            </div>
            <!-- Ascended placeholder maybe? Or just track through Essence -->
          </div>
        </section>

        <!-- Ascension Tab (Hidden initially) -->
        <section id="tabContent-ascension" class="tab-content hidden">
          <h2 class="text-xl font-semibold text-gray-700 mb-4">
            Ascension <i class="fa-solid fa-person-hiking text-fuchsia-500"></i>
          </h2>
          <p class="text-sm text-gray-600 mb-4">
            Reach Level 50 and Collect all Rare items to Ascend!
          </p>
          <div
            class="bg-gradient-to-r from-purple-50 to-fuchsia-50 p-6 rounded-lg border border-fuchsia-200 text-center shadow-inner"
          >
            <h3 class="text-lg font-semibold text-fuchsia-800">
              Reset your progress to gain Essence
              <span class="text-xl text-fuchsia-600">ğŸŒŒ</span>!
            </h3>
            <p class="text-fuchsia-700 mt-2">
              Essence provides powerful permanent upgrades.
            </p>
            <p class="mt-4">
              You will gain
              <span
                id="essenceOnAscend"
                class="font-bold text-xl text-fuchsia-800"
                >0</span
              >
              ğŸŒŒ upon Ascending.
            </p>
            <button
              id="ascendButton"
              class="btn btn-primary mt-6 bg-fuchsia-600 hover:bg-fuchsia-700 border-fuchsia-600"
              disabled
            >
              Ascend Now
            </button>
            <p class="text-xs text-gray-500 mt-4">
              (Resets Level, XP, Shards, Rolls, Infusion Levels, Inventory<br />Keeps
              Achievements, Sets, Essence, Ascension Upgrades)
            </p>

            <div
              id="ascensionUpgrades"
              class="mt-8 border-t border-fuchsia-200 pt-6"
            >
              <h4 class="text-md font-semibold text-fuchsia-800 mb-3">
                Ascension Upgrades
              </h4>
              <p class="text-sm text-fuchsia-600 italic">
                (Coming Soon in V5!)
              </p>
              <!-- Upgrade purchase UI will go here -->
            </div>
          </div>
        </section>
      </main>

      <footer class="mt-5 border-t pt-4 border-gray-200 text-center">
        <p class="text-xs text-gray-400">
          RNG Item Collector V4 - Save data is stored in your browser's local
          storage.
        </p>
        <button id="resetDataButton" class="btn btn-xs btn-danger mt-2">
          Reset All Game Data
        </button>
        <span class="text-xs text-gray-400 mx-2">|</span>
        <span class="text-xs text-gray-400"
          >Item Effects: <span id="cumulativeEffectsDisplay">None</span></span
        >
      </footer>
    </div>

    <div id="toast" class="info">Notification Message</div>

    <script>
      // --- Game Configuration V4 ---

      // --- Constants ---
      const SAVE_KEY_PREFIX = 'rngCollectorV4_'; // Changed Prefix! Resets previous saves.
      const BASE_XP_PER_LEVEL = 100;
      const XP_LEVEL_MULTIPLIER = 1.4;
      const ASCENSION_UNLOCK_LEVEL = 30; // Lowered for easier testing/showcase
      const ASCENSION_UNLOCK_RARITY = 'Rare'; // Collect all items of this rarity to unlock
      const ANOMALY_TICK_INTERVAL = 10000; // Check for anomalies every 10 seconds (ms)
      const ANOMALY_BASE_CHANCE = 0.05; // 5% base chance per tick

      // --- Rarity Configuration --- (Added Ascension values - theoretical for now)
      const rarityConfig = {
          // index used for sorting
          'Common':    { index: 0, weight: 55, colorClass: 'rarity-Common',    bgClass: 'bg-rarity-Common', sellValue: 1, infusionBaseCost: 5, infusionLevelMult: 1.5, xpOnRoll: 1 },
          'Uncommon':  { index: 1, weight: 26, colorClass: 'rarity-Uncommon',  bgClass: 'bg-rarity-Uncommon', sellValue: 3, infusionBaseCost: 15, infusionLevelMult: 1.8, xpOnRoll: 2 },
          'Rare':      { index: 2, weight: 10, colorClass: 'rarity-Rare',      bgClass: 'bg-rarity-Rare', sellValue: 10, infusionBaseCost: 50, infusionLevelMult: 2.2, xpOnRoll: 5 },
          'Epic':      { index: 3, weight: 5,  colorClass: 'rarity-Epic',      bgClass: 'bg-rarity-Epic', sellValue: 30, infusionBaseCost: 200, infusionLevelMult: 2.8, xpOnRoll: 15 },
          'Legendary': { index: 4, weight: 3,  colorClass: 'rarity-Legendary', bgClass: 'bg-rarity-Legendary', sellValue: 100, infusionBaseCost: 1000, infusionLevelMult: 3.5, xpOnRoll: 50 },
          'Mythic':    { index: 5, weight: 1,  colorClass: 'rarity-Mythic',    bgClass: 'bg-rarity-Mythic', sellValue: 500, infusionBaseCost: 5000, infusionLevelMult: 5.0, xpOnRoll: 200 },
           // Ascended - not obtainable by roll, potentially via crafting or events later
          'Ascended': { index: 6, weight: 0, colorClass: 'rarity-Ascended', bgClass: 'bg-rarity-Ascended', sellValue: 10000, infusionBaseCost: 50000, infusionLevelMult: 6.0, xpOnRoll: 1000 }
      };
      const rarities = Object.keys(rarityConfig);
      const totalBaseWeight = rarities.reduce((sum, r) => sum + rarityConfig[r].weight, 0);


      // --- Items V4 (Added passive 'effect' property to some) ---
      const items = [
          // Common
          { name: 'Smooth Pebble', rarity: 'Common', icon: 'ğŸª¨', description: 'Surprisingly smooth.' },
          { name: 'Twisted Twig', rarity: 'Common', icon: 'ğŸŒ¿', description: 'Oddly shaped branch.', effect: { type: 'xpPerRollFlat', value: 0.1 } },
          { name: 'Dust Bunny', rarity: 'Common', icon: 'ğŸ’¨', description: 'It seems to stare back.' },
          { name: 'Plain Button', rarity: 'Common', icon: 'ğŸ”˜', description: 'Missing from a coat?' },
          { name: 'Cracked Acorn', rarity: 'Common', icon: 'ğŸŒ°', description: 'Something tried to get inside.' },
          { name: 'Faded Leaf', rarity: 'Common', icon: 'ğŸ‚', description: 'Lost its color.' },
          { name: 'Bent Nail', rarity: 'Common', icon: 'ğŸ”©', description: 'Hit something hard.' },
          { name: 'Mud Clump', rarity: 'Common', icon: 'ğŸ’©', description: 'Best not to ask.' },
          { name: 'Lint Ball', rarity: 'Common', icon: 'ğŸ§¶', description: 'Dryer fresh.' },
          { name: 'Scratched Coin', rarity: 'Common', icon: 'ğŸª™', description: 'Worthless, but has character.', effect: { type: 'shardPerRollFlat', value: 0.05 } },
          // ... (keep ~30 Commons, maybe add 1-2 more with tiny effects)

          // Uncommon
          { name: 'Shiny Stone', rarity: 'Uncommon', icon: 'ğŸ’', description: 'Catches the light.', effect: { type: 'shardPerRollPercent', value: 0.5 } }, // 0.5% bonus shards/roll
          { name: 'Colorful Feather', rarity: 'Uncommon', icon: 'ğŸª¶', description: 'From an exotic bird.' },
          { name: 'Polished Button', rarity: 'Uncommon', icon: 'ğŸ”˜', description: 'Gleams with care.' },
          { name: 'Sturdy Branch', rarity: 'Uncommon', icon: 'ğŸŒ³', description: 'Decent walking stick.' },
          { name: 'Unusual Seed', rarity: 'Uncommon', icon: 'ğŸŒ±', description: 'What might grow?' },
          { name: 'Small Fossil', rarity: 'Uncommon', icon: 'ğŸ¦´', description: 'Tiny piece of ancient life.', effect: { type: 'xpPerRollFlat', value: 0.2 } },
          { name: 'Glass Marble', rarity: 'Uncommon', icon: 'ğŸ”®', description: 'Perfectly spherical.' },
          { name: 'Iron Key', rarity: 'Uncommon', icon: 'ğŸ”‘', description: 'What does it unlock?' },
          // ... (keep ~30 Uncommons, add 2-3 more with small effects)
          { name: 'Magnetic Lodestone Chip', rarity: 'Uncommon', icon: 'ğŸ§²', description: 'Pulls weakly.', effect: { type: 'shardBonusCommonRoll', value: 1 } }, // +1 shard on Common roll

          // Rare
          { name: 'Glowing Mushroom', rarity: 'Rare', icon: 'ğŸ„', description: 'Emits a soft, eerie light.', effect: { type: 'anomalyChanceMultiplier', value: 1.02 } }, // +2% anomaly chance
          { name: 'Enchanted Pebble', rarity: 'Rare', icon: 'ğŸª„', description: 'Warm and hums faintly.', effect: { type: 'xpPerRollPercent', value: 1 } }, // +1% XP/roll
          { name: 'Miniature Telescope', rarity: 'Rare', icon: 'ğŸ”­', description: 'Sees slightly farther.' },
          { name: 'Ancient Coin', rarity: 'Rare', icon: 'ğŸª™', description: 'Forgotten ruler depicted.', effect: { type: 'sellValuePercent', value: 1 } }, // +1% sell value
          { name: 'Phoenix Down (Small)', rarity: 'Rare', icon: 'ğŸ”¥', description: 'Tiny, warm feather.' }, // Could be crafting ingredient
          { name: 'Crystal Shard', rarity: 'Rare', icon: 'ğŸ’', description: 'Resonates with energy.', effect: { type: 'infusionCostPercent', value: -0.5 } }, // -0.5% infusion cost
          // ... (keep ~30 Rares, add 3-4 more with noticeable effects)
          { name: 'Humming Rune Stone', rarity: 'Rare', icon: 'ğŸ—¿', description: 'Vibrates gently in hand.', effect: { type: 'commonRarityWeightPercent', value: -1 } }, // Decrease common chance slightly

          // Epic
          { name: 'Dragon Tear', rarity: 'Epic', icon: 'ğŸ’§', description: 'Solidified sorrow, still warm.', effect: { type: 'rareRarityWeightPercent', value: 1 } }, // Increase Rare chance slightly
          { name: 'Fragment of a Star', rarity: 'Epic', icon: 'â­', description: 'Pulses faintly, heavy.', effect: { type: 'xpPerRollPercent', value: 3 } }, // +3% XP/roll
          { name: 'Sunstone', rarity: 'Epic', icon: 'â˜€ï¸', description: 'Radiates warmth and light.', effect: { type: 'shardPerRollPercent', value: 2 } }, // +2% Shards/roll
          { name: 'Whispering Shell', rarity: 'Epic', icon: 'ğŸš', description: 'Ancient voices murmur.' }, // Could trigger unique anomaly?
          // ... (keep ~20 Epics, ensure most have effects now)
          { name: 'Aetherium Crystal', rarity: 'Epic', icon: 'âœ¨', description: 'Gateway hums.', effect: { type: 'anomalyChanceMultiplier', value: 1.05 } }, // +5% anomaly chance

          // Legendary
          { name: 'Heart of the Mountain', rarity: 'Legendary', icon: 'ğŸ’–', description: 'Beats with slow rhythm.', effect: { type: 'xpPerRollFlat', value: 10 } },
          { name: 'Celestial Orb', rarity: 'Legendary', icon: 'ğŸŒŒ', description: 'Contains swirling galaxy.', effect: { type: 'epicRarityWeightPercent', value: 1.5 } },
          { name: 'Philosopher\'s Stone Shard', rarity: 'Legendary', icon: 'ğŸ§ª', description: 'Tiny ultimate catalyst.', effect: { type: 'infusionCostPercent', value: -2 } }, // -2% infusion cost
          { name: 'Timeless Sandglass', rarity: 'Legendary', icon: 'â³', description: 'Sand defies gravity.', effect: { type: 'anomalyDurationMultiplier', value: 1.1 } }, // +10% anomaly duration
          // ... (keep ~15 Legendaries, ALL should have significant effects)
          { name: 'Feather from an Archangel', rarity: 'Legendary', icon: 'ğŸ•Šï¸', description: 'Impossibly light.', effect: { type: 'mythicRarityWeightPercent', value: 0.5 } },

          // Mythic
          { name: 'Shard of Creation', rarity: 'Mythic', icon: 'ğŸ’«', description: 'Echo of the universe.', effect: { type: 'allRarityWeightPercentAboveCommon', value: 0.5 } }, // +0.5% to Unc+ weight
          { name: 'Heartwood of Yggdrasil', rarity: 'Mythic', icon: 'ğŸŒ²', description: 'Connects all realms.', effect: { type: 'setBonusMultiplier', value: 1.1 } }, // +10% effect of completed sets
          { name: 'Chronoscrystal Fragment', rarity: 'Mythic', icon: 'âŒ›', description: 'Time swirls within.', effect: { type: 'anomalyTickIntervalMultiplier', value: 0.95 } }, // 5% faster anomaly checks
          { name: 'The Unmaking Catalyst', rarity: 'Mythic', icon: 'ğŸ’¥', description: 'Pure entropic potential.', effect: { type: 'rerollBelowEpicChance', value: 0.01 } }, // 1% chance to auto-reroll Common/Unc/Rare results
          { name: 'Echo of the First Song', rarity: 'Mythic', icon: 'ğŸ¶', description: 'Sound solidified.', effect: { type: 'xpPerRollPercent', value: 10 } },
          { name: 'Tiamat\'s Scale Fragment', rarity: 'Mythic', icon: 'ğŸ²', description: 'Power of five dragons.', effect: { type: 'shardPerRollPercent', value: 5 } },
          { name: 'The Never-Ending Bloom', rarity: 'Mythic', icon: 'ğŸŒ¸', description: 'Immune to time.', effect: { type: 'anomalyNegativeEffectResist', value: 0.15 } }, // 15% chance to ignore negative anomalies
          { name: 'Kernel of Infinite Possibility', rarity: 'Mythic', icon: 'âœ¨', description: 'Tastes like numbers.', effect: { type: 'legendaryRarityWeightPercent', value: 1 } },
      ]; // Total items kept roughly similar (~130), focused on adding effects. Full list abbreviated. Fill as needed.

       // Add full item list back if needed
      const fullItems = [
              // Common (Sell: 1)
              { name: 'Smooth Pebble', rarity: 'Common', icon: 'ğŸª¨', description: 'Surprisingly smooth.' },
              { name: 'Twisted Twig', rarity: 'Common', icon: 'ğŸŒ¿', description: 'Oddly shaped branch.', effect: { type: 'xpPerRollFlat', value: 0.1, desc: "+0.1 XP/Roll" } },
              { name: 'Dust Bunny', rarity: 'Common', icon: 'ğŸ’¨', description: 'It seems to stare back.' },
              { name: 'Plain Button', rarity: 'Common', icon: 'ğŸ”˜', description: 'Missing from a coat?' },
              { name: 'Cracked Acorn', rarity: 'Common', icon: 'ğŸŒ°', description: 'Something tried to get inside.' },
              { name: 'Faded Leaf', rarity: 'Common', icon: 'ğŸ‚', description: 'Lost its color.' },
              { name: 'Bent Nail', rarity: 'Common', icon: 'ğŸ”©', description: 'Hit something hard.' },
              { name: 'Mud Clump', rarity: 'Common', icon: 'ğŸ’©', description: 'Best not to ask.' },
              { name: 'Lint Ball', rarity: 'Common', icon: 'ğŸ§¶', description: 'Dryer fresh.' },
              { name: 'Scratched Coin', rarity: 'Common', icon: 'ğŸª™', description: 'Worthless, but has character.', effect: { type: 'shardPerRollFlat', value: 0.05, desc: "+0.05 Shards/Roll"} },
              { name: 'Dull Feather', rarity: 'Common', icon: 'ğŸª¶', description: 'From a common bird.' },
              { name: 'Small Worm', rarity: 'Common', icon: 'ğŸ›', description: 'Wiggles slightly.' },
              { name: 'Torn Cloth Scrap', rarity: 'Common', icon: 'ğŸ§µ', description: 'Part of a story.' },
              { name: 'Empty Seed Pod', rarity: 'Common', icon: 'ğŸŒ±', description: 'Potential unfulfilled.' },
              { name: 'Chunk of Bark', rarity: 'Common', icon: 'ğŸªµ', description: 'Smells faintly of pine.' },
              { name: 'Common Seashell', rarity: 'Common', icon: 'ğŸš', description: 'Listen closely... nothing.' },
              { name: 'Gravel Bit', rarity: 'Common', icon: 'âš«', description: 'Just a little rock.' },
              { name: 'Blunt Stick', rarity: 'Common', icon: 'ğŸŒ²', description: 'Not very pointy.' },
              { name: 'Simple Thread', rarity: 'Common', icon: 'ğŸ§µ', description: 'Could mend a tear.' },
              { name: 'Dried Weed', rarity: 'Common', icon: 'ğŸŒ¾', description: 'Crumbles easily.' },
              { name: 'Old Bottle Cap', rarity: 'Common', icon: 'ğŸ¾', description: 'Forgotten beverage.' },
              { name: 'Rusted Washer', rarity: 'Common', icon: 'âš™ï¸', description: 'Seen better days.' },
              { name: 'Tiny Snail Shell', rarity: 'Common', icon: 'ğŸŒ', description: 'Former resident moved on.' },
              { name: 'Pine Needle', rarity: 'Common', icon: 'ğŸŒ²', description: 'Sharp!' },
              { name: 'Common Flower Petal', rarity: 'Common', icon: 'ğŸŒ¸', description: 'Delicate and plain.' },
              { name: 'Discarded Shoelace Tip', rarity: 'Common', icon: 'ã€°ï¸', description: 'An aglet, free at last.'},
              { name: 'Single Strand of Hair', rarity: 'Common', icon: 'ğŸ‘±', description: 'Whose could it be?'},
              { name: 'Piece of Chewed Gum', rarity: 'Common', icon: 'ğŸ¬', description: 'Ew. Still sticky.'},
              { name: 'Bottle Glass Shard', rarity: 'Common', icon: 'ğŸ§Š', description: 'Smoothed by time, probably.'},
              { name: 'Chip of Dried Paint', rarity: 'Common', icon: 'ğŸ¨', description: 'Lead-based? Maybe.'},

              // Uncommon
              { name: 'Shiny Stone', rarity: 'Uncommon', icon: 'ğŸ’', description: 'Catches the light.', effect: { type: 'shardPerRollPercent', value: 0.5, desc: "+0.5% Shards/Roll" } },
              { name: 'Colorful Feather', rarity: 'Uncommon', icon: 'ğŸª¶', description: 'From an exotic bird.' },
              { name: 'Polished Button', rarity: 'Uncommon', icon: 'ğŸ”˜', description: 'Gleams with care.' },
              { name: 'Sturdy Branch', rarity: 'Uncommon', icon: 'ğŸŒ³', description: 'Decent walking stick.' },
              { name: 'Unusual Seed', rarity: 'Uncommon', icon: 'ğŸŒ±', description: 'What might grow?' },
              { name: 'Small Fossil', rarity: 'Uncommon', icon: 'ğŸ¦´', description: 'Tiny piece of ancient life.', effect: { type: 'xpPerRollFlat', value: 0.2, desc: "+0.2 XP/Roll" } },
              { name: 'Glass Marble', rarity: 'Uncommon', icon: 'ğŸ”®', description: 'Perfectly spherical.' },
              { name: 'Iron Key', rarity: 'Uncommon', icon: 'ğŸ”‘', description: 'What does it unlock?' },
              { name: 'Silverfish Scale', rarity: 'Uncommon', icon: 'âœ¨', description: 'Oddly metallic.' },
              { name: 'Four-Leaf Clover', rarity: 'Uncommon', icon: 'ğŸ€', description: 'Classic symbol of luck.', effect: { type: 'commonRarityWeightPercent', value: -0.2, desc: "-0.2% Common Weight" } }, // Slightly reduces common chance
              { name: 'Intact Seashell', rarity: 'Uncommon', icon: 'ğŸš', description: 'A perfect specimen.' },
              { name: 'Small Geode Fragment', rarity: 'Uncommon', icon: 'ğŸª¨', description: 'Sparkles within.' },
              { name: 'Bird\'s Eggshell Fragment', rarity: 'Uncommon', icon: 'ğŸ¥š', description: 'Speckled blue.' },
              { name: 'Copper Wire', rarity: 'Uncommon', icon: 'ğŸ”—', description: 'Conducts potential.', effect: { type: 'shardPerRollFlat', value: 0.1, desc: "+0.1 Shards/Roll"} },
              { name: 'Worn Leather Strap', rarity: 'Uncommon', icon: 'ğŸ—ï¸', description: 'Strong despite its age.' },
              { name: 'Smooth River Stone', rarity: 'Uncommon', icon: 'ğŸï¸', description: 'Shaped by water.' },
              { name: 'Small Crystal Shard', rarity: 'Uncommon', icon: 'ğŸ§Š', description: 'Glimmers faintly.' },
              { name: 'Polished Acorn', rarity: 'Uncommon', icon: 'ğŸŒ°', description: 'Good luck charm?' },
              { name: 'Dried Starfish', rarity: 'Uncommon', icon: 'â­', description: 'Souvenir from the sea.' },
              { name: 'Whistle', rarity: 'Uncommon', icon: 'ğŸ“¢', description: 'Makes a shrill sound.' },
              { name: 'Clay Pipe Fragment', rarity: 'Uncommon', icon: 'ğŸš¬', description: 'Someone enjoyed this once.'},
              { name: 'Lost Fishing Hook', rarity: 'Uncommon', icon: 'ğŸ£', description: 'The one that got away.'},
              { name: 'Lump of Coal', rarity: 'Uncommon', icon: 'âš«', description: 'Potential energy.'},
              { name: 'Sea Glass (Green)', rarity: 'Uncommon', icon: 'ğŸŸ©', description: 'Tumbled by the waves.'},
              { name: 'Ball Bearing', rarity: 'Uncommon', icon: 'âš«', description: 'Smooth and heavy.'},
              { name: 'Fancy Bottle Cap', rarity: 'Uncommon', icon: 'âšœï¸', description: 'Imported soda maybe?'},
              { name: 'Quartz Pebble', rarity: 'Uncommon', icon: 'ğŸª¨', description: 'Slightly translucent.', effect: { type: 'sellValuePercent', value: 0.2, desc: "+0.2% Sell Value" } },
              { name: 'Magnetic Lodestone Chip', rarity: 'Uncommon', icon: 'ğŸ§²', description: 'Pulls weakly.', effect: { type: 'shardBonusCommonRoll', value: 1, desc: "+1 Shard on Common Rolls"} },
              { name: 'Beeswax Chunk', rarity: 'Uncommon', icon: 'ğŸ', description: 'Smells sweet.'},
              { name: 'Simple Iron Ring', rarity: 'Uncommon', icon: 'ğŸ’', description: 'Plain and functional.'},

               // Rare
              { name: 'Glowing Mushroom', rarity: 'Rare', icon: 'ğŸ„', description: 'Emits a soft, eerie light.', effect: { type: 'anomalyChanceMultiplier', value: 1.02, desc: "+2% Anomaly Chance"} },
              { name: 'Enchanted Pebble', rarity: 'Rare', icon: 'ğŸª„', description: 'Warm and hums faintly.', effect: { type: 'xpPerRollPercent', value: 1, desc: "+1% XP/Roll" } },
              { name: 'Miniature Telescope', rarity: 'Rare', icon: 'ğŸ”­', description: 'Sees slightly farther.', effect: { type: 'uncommonRarityWeightPercent', value: 0.5, desc: "+0.5% Unc. Weight"} },
              { name: 'Ancient Coin', rarity: 'Rare', icon: 'ğŸª™', description: 'Forgotten ruler depicted.', effect: { type: 'sellValuePercent', value: 1, desc: "+1% Sell Value" } },
              { name: 'Phoenix Down (Small)', rarity: 'Rare', icon: 'ğŸ”¥', description: 'Tiny, warm feather.' },
              { name: 'Crystal Shard', rarity: 'Rare', icon: 'ğŸ’', description: 'Resonates with energy.', effect: { type: 'infusionCostPercent', value: -0.5, desc: "-0.5% Infusion Cost"} },
              { name: 'Mermaid Scale', rarity: 'Rare', icon: 'ğŸ§œâ€â™€ï¸', description: 'Iridescent, smells of sea.' },
              { name: 'Ornate Key', rarity: 'Rare', icon: 'ğŸ—ï¸', description: 'Unlocks something important.' },
              { name: 'Petrified Wood', rarity: 'Rare', icon: 'ğŸªµ', description: 'Wood turned to stone.' },
              { name: 'Golden Acorn', rarity: 'Rare', icon: 'ğŸŒŸ', description: 'Said to bring prosperity.' },
              { name: 'Small Sapphire', rarity: 'Rare', icon: 'ğŸ’', description: 'Deep blue, uncut gem.' },
              { name: 'Lightning-Struck Bark', rarity: 'Rare', icon: 'âš¡', description: 'Crackles with energy.' },
              { name: 'Message in a Bottle', rarity: 'Rare', icon: 'ğŸ¾', description: 'Faded, cryptic note.' },
              { name: 'Dragonfly Wing', rarity: 'Rare', icon: 'ğŸ¦‹', description: 'Delicate, yet strong.' },
              { name: 'Elf Arrowhead', rarity: 'Rare', icon: 'ğŸ¹', description: 'Masterfully crafted obsidian.' },
              { name: 'Geode (Uncracked)', rarity: 'Rare', icon: 'ğŸŒ‘', description: 'Heavy. Treasures within?' },
              { name: 'Silver Locket (Empty)', rarity: 'Rare', icon: 'ğŸ©·', description: 'Holds forgotten memories.' },
              { name: 'Sunken Doubloon', rarity: 'Rare', icon: 'ğŸ’°', description: 'Feels heavy with history.' },
              { name: 'Obsidian Shard', rarity: 'Rare', icon: 'ğŸ”ª', description: 'Naturally sharp volcanic glass.' },
              { name: 'Fairy Wing Dust', rarity: 'Rare', icon: 'ğŸ§š', description: 'Glitters with unseen magic.' },
              { name: 'Golem Bolt', rarity: 'Rare', icon: 'ğŸ”©', description: 'Surprisingly heavy iron bolt.' },
              { name: 'Polished Amber (w/ Insect)', rarity: 'Rare', icon: 'ğŸ¦Ÿ', description: 'Life trapped in time.' },
              { name: 'Whale Bone Fragment', rarity: 'Rare', icon: 'ğŸ³', description: 'Smooth and porous.' },
              { name: 'Humming Rune Stone', rarity: 'Rare', icon: 'ğŸ—¿', description: 'Vibrates gently in hand.', effect: { type: 'commonRarityWeightPercent', value: -1, desc: "-1% Common Weight"} },
              { name: 'Crystallized Honey', rarity: 'Rare', icon: 'ğŸ¯', description: 'Ancient and unnaturally hard.' },
              { name: 'Basilisk Scale', rarity: 'Rare', icon: 'ğŸ', description: 'Reflects light strangely.' },
              { name: 'Eagle Talon', rarity: 'Rare', icon: 'ğŸ¦…', description: 'Impressively sharp.' },
              { name: 'Sea Glass (Cobalt Blue)', rarity: 'Rare', icon: 'ğŸŸ¦', description: 'A rare color find.' },
              { name: 'Miniature Hourglass', rarity: 'Rare', icon: 'â³', description: 'The sand flows slowly.' },
              { name: 'Opal Chip', rarity: 'Rare', icon: 'âœ¨', description: 'Flashes with internal fire.' },

              // Epic
              { name: 'Dragon Tear', rarity: 'Epic', icon: 'ğŸ’§', description: 'Solidified sorrow, still warm.', effect: { type: 'rareRarityWeightPercent', value: 1, desc: "+1% Rare Weight" } },
              { name: 'Fragment of a Star', rarity: 'Epic', icon: 'â­', description: 'Pulses faintly, heavy.', effect: { type: 'xpPerRollPercent', value: 3, desc: "+3% XP/Roll" } },
              { name: 'Sunstone', rarity: 'Epic', icon: 'â˜€ï¸', description: 'Radiates warmth and light.', effect: { type: 'shardPerRollPercent', value: 2, desc: "+2% Shards/Roll" } },
              { name: 'Whispering Shell', rarity: 'Epic', icon: 'ğŸš', description: 'Ancient voices murmur.' }, // Event?
              { name: 'Shadow Essence', rarity: 'Epic', icon: 'âš«', description: 'Absorbs light, cold.' },
              { name: 'Griffin Feather', rarity: 'Epic', icon: 'ğŸª¶', description: 'Impossibly large and sharp.' },
              { name: 'Moon Pearl', rarity: 'Epic', icon: 'ğŸŒ•', description: 'Glows soft silver, cool.' },
              { name: 'Rune Tablet Fragment', rarity: 'Epic', icon: 'ğŸ“œ', description: 'Symbols shift and writhe.', effect: { type: 'xpPerRollFlat', value: 5, desc: "+5 XP/Roll"} },
              { name: 'Meteorite Chunk', rarity: 'Epic', icon: 'â˜„ï¸', description: 'Otherworldly metal alloys.' },
              { name: 'Manticore Spike', rarity: 'Epic', icon: 'ğŸ¦‚', description: 'Venom might still be potent.' },
              { name: 'Ent Bark', rarity: 'Epic', icon: 'ğŸŒ³', description: 'Feels ancient and alive.' },
              { name: 'Essence of Fire', rarity: 'Epic', icon: 'ğŸ”¥', description: 'A contained, swirling flame.' },
              { name: 'Ice Wyrm Scale', rarity: 'Epic', icon: 'â„ï¸', description: 'Permanently freezing cold.' },
              { name: 'Golden Fleece Strand', rarity: 'Epic', icon: 'ğŸ‘', description: 'Shimmers with divine protection.', effect: { type: 'sellValuePercent', value: 2, desc: "+2% Sell Value" } },
              { name: 'Pocket Watch (Stopped)', rarity: 'Epic', icon: 'â±ï¸', description: 'Stuck at an impossible time.' },
              { name: 'Giant\'s Tooth', rarity: 'Epic', icon: 'ğŸ¦·', description: 'Bigger than your fist.' },
              { name: 'Leviathan Barnacle', rarity: 'Epic', icon: 'ğŸŒŠ', description: 'Holds the pressure of the deep.' },
              { name: 'Djinn Lamp Chip', rarity: 'Epic', icon: 'ğŸº', description: 'Warm, smells of ozone and spice.' },
              { name: 'Philosopher\'s Dewdrop', rarity: 'Epic', icon: 'ğŸ’§', description: 'Glimmers with power.' },
              { name: 'Aetherium Crystal', rarity: 'Epic', icon: 'âœ¨', description: 'Gateway hums.', effect: { type: 'anomalyChanceMultiplier', value: 1.05, desc: "+5% Anomaly Chance"} },

              // Legendary
              { name: 'Heart of the Mountain', rarity: 'Legendary', icon: 'ğŸ’–', description: 'Beats with slow rhythm.', effect: { type: 'xpPerRollFlat', value: 10, desc: "+10 XP/Roll"} },
              { name: 'Celestial Orb', rarity: 'Legendary', icon: 'ğŸŒŒ', description: 'Contains swirling galaxy.', effect: { type: 'epicRarityWeightPercent', value: 1.5, desc: "+1.5% Epic Weight" } },
              { name: 'Philosopher\'s Stone Shard', rarity: 'Legendary', icon: 'ğŸ§ª', description: 'Tiny ultimate catalyst.', effect: { type: 'infusionCostPercent', value: -2, desc: "-2% Infusion Cost" } },
              { name: 'Timeless Sandglass', rarity: 'Legendary', icon: 'â³', description: 'Sand defies gravity.', effect: { type: 'anomalyDurationMultiplier', value: 1.1, desc: "+10% Anomaly Duration" } },
              { name: 'Prismatic Dragon Scale', rarity: 'Legendary', icon: 'ğŸ‰', description: 'Shifts through colors.', effect: { type: 'shardPerRollPercent', value: 3, desc: "+3% Shards/Roll" } },
              { name: 'World Tree Leaf', rarity: 'Legendary', icon: 'ğŸŒ³', description: 'Radiates life energy.' },
              { name: 'Kraken Ink Sac (Dried)', rarity: 'Legendary', icon: 'ğŸ™', description: 'Deeper than night.' },
              { name: 'Archmage\'s Forgotten Spellbook Page', rarity: 'Legendary', icon: 'ğŸ“–', description: 'Words burn.' },
              { name: 'Tear of a Dying Star', rarity: 'Legendary', icon: 'ğŸŒŸ', description: 'Intensely hot.' },
              { name: 'Fragment of True Ice', rarity: 'Legendary', icon: 'ğŸ§Š', description: 'Cannot be melted.' },
              { name: 'Gorgon\'s Eye (Petrified)', rarity: 'Legendary', icon: 'ğŸ‘ï¸', description: 'Chilling orb.' },
              { name: 'Phoenix Ember', rarity: 'Legendary', icon: 'ğŸ”¥', description: 'Glows with rebirth.' },
              { name: 'Core of a Storm Giant', rarity: 'Legendary', icon: 'âš¡', description: 'Arcs with lightning.' },
              { name: 'Void Seed', rarity: 'Legendary', icon: 'âš«', description: 'Silent emptiness.' },
              { name: 'Feather from an Archangel', rarity: 'Legendary', icon: 'ğŸ•Šï¸', description: 'Impossibly light.', effect: { type: 'mythicRarityWeightPercent', value: 0.5, desc: "+0.5% Mythic Weight" } },

               // Mythic
              { name: 'Shard of Creation', rarity: 'Mythic', icon: 'ğŸ’«', description: 'Echo of the universe.', effect: { type: 'allRarityWeightPercentAboveCommon', value: 0.5, desc: "+0.5% Unc+ Weights" } },
              { name: 'Heartwood of Yggdrasil', rarity: 'Mythic', icon: 'ğŸŒ²', description: 'Connects all realms.', effect: { type: 'setBonusMultiplier', value: 1.1, desc: "+10% Set Bonus Effect" } },
              { name: 'Chronoscrystal Fragment', rarity: 'Mythic', icon: 'âŒ›', description: 'Time swirls within.', effect: { type: 'anomalyTickIntervalMultiplier', value: 0.95, desc: "5% Faster Anomaly Checks"} },
              { name: 'The Unmaking Catalyst', rarity: 'Mythic', icon: 'ğŸ’¥', description: 'Entropic potential.', effect: { type: 'rerollBelowEpicChance', value: 0.01, desc: "1% chance auto-reroll Common/Unc/Rare" } },
              { name: 'Echo of the First Song', rarity: 'Mythic', icon: 'ğŸ¶', description: 'Sound solidified.', effect: { type: 'xpPerRollPercent', value: 10, desc: "+10% XP/Roll" } },
              { name: 'Tiamat\'s Scale Fragment', rarity: 'Mythic', icon: 'ğŸ²', description: 'Power of five dragons.', effect: { type: 'shardPerRollPercent', value: 5, desc: "+5% Shards/Roll"} },
              { name: 'The Never-Ending Bloom', rarity: 'Mythic', icon: 'ğŸŒ¸', description: 'Immune to time.', effect: { type: 'anomalyNegativeEffectResist', value: 0.15, desc: "15% Resist Negative Anomalies"} },
              { name: 'Kernel of Infinite Possibility', rarity: 'Mythic', icon: 'âœ¨', description: 'Tastes like numbers.', effect: { type: 'legendaryRarityWeightPercent', value: 1, desc: "+1% Legendary Weight" } },
          ];
          items = fullItems; // Make sure we use the full list with effects

      const totalItemCounts = (() => { // Use IIFE to calculate immediately
           const counts = {};
           rarities.forEach(r => counts[r] = 0);
           items.forEach(item => { if (counts[item.rarity] !== undefined) counts[item.rarity]++; });
           return counts;
       })();


      // --- Crafting Recipes V4 ---
      const craftingRecipes = [
          { // Combine Commons into Uncommon currency (Shards)
               id: 'commonShards1', output: { type: 'shards', amount: 3 }, name: "Shard Dusting", icon: "âœ¨",
               ingredients: [{ name: 'Smooth Pebble', count: 5 }, { name: 'Twisted Twig', count: 5 }],
               description: "Break down basic components for Shards.", unlockLevel: 1
          },
          { // Combine different Commons into a specific Uncommon item
               id: 'makeShinyStone', output: { type: 'item', name: 'Shiny Stone', amount: 1 }, name: "Polished Treasure", icon: "ğŸ’",
              ingredients: [{ name: 'Smooth Pebble', count: 10 }, { name: 'Gravel Bit', count: 8 }, { name: 'Lint Ball', count: 3}],
              description: "Polish and combine mundane stones.", unlockLevel: 3
          },
           { // Combine Uncommons into Shards
              id: 'uncommonShards1', output: { type: 'shards', amount: 10 }, name: "Uncommon Essence", icon: "âœ¨",
              ingredients: [{ name: 'Shiny Stone', count: 2 }, { name: 'Colorful Feather', count: 2 }, { name: 'Copper Wire', count: 2}],
              description: "Extract more Shards from less common materials.", unlockLevel: 5
          },
           { // Combine Uncommons into a Rare item
              id: 'makeGlowingMushroom', output: { type: 'item', name: 'Glowing Mushroom', amount: 1 }, name: "Fungal Alchemy", icon: "ğŸ„",
               ingredients: [{ name: 'Unusual Seed', count: 5 }, { name: 'Mud Clump', count: 10 }, { name: 'Silverfish Scale', count: 1}],
               description: "Cultivate an eerie light source.", unlockLevel: 8
          },
          { // Craft a consumable "Guaranteed Uncommon+" Roll
              id: 'craftGuaranteedUncommonRoll', output: { type: 'guaranteedRoll', rarity: 'Uncommon', amount: 1 }, name: "Minor Luck Charm", icon: "ğŸ€",
              ingredients: [{ name: 'Four-Leaf Clover', count: 1 }, { name: 'Shiny Stone', count: 3 }, { name: 'Scratched Coin', count: 20}],
               description: "A small charm ensuring slightly better luck.", unlockLevel: 6
           },
          { // Craft a consumable "Guaranteed Rare+" Roll
              id: 'craftGuaranteedRareRoll', output: { type: 'guaranteedRoll', rarity: 'Rare', amount: 1 }, name: "Potent Luck Charm", icon: "ğŸŒŸ",
               ingredients: [{ name: 'Golden Acorn', count: 1 }, { name: 'Crystal Shard', count: 2 }, { name: 'Iron Key', count: 5 }],
              description: "A powerful charm guaranteeing a rarer find.", unlockLevel: 12
           },
           // Add more recipes - e.g., converting many commons/uncommons directly to XP
            {
                id: 'xpFromCommons', output: { type: 'xp', amount: 50 }, name: "Experience Distillation", icon: "ğŸ§ ",
                ingredients: [{ name: 'Plain Button', count: 15 }, { name: 'Faded Leaf', count: 15 }, { name: 'Chunk of Bark', count: 15 }],
                description: "Refine mundane items into raw experience.", unlockLevel: 4
            }
            // Consider recipes that output Ascended items LATER (maybe require Essence?)
       ];


       // --- Anomalies V4 ---
       const anomalies = [
           { // Positive
               id: 'shardSurge', name: "Shard Surge", duration: 60, type: 'good', chance: 1.0,
               description: "All Shard gains doubled!",
               effect: { type: 'shardMultiplier', multiplier: 2.0 }
           },
           { // Positive
               id: 'xpBoost', name: "XP Boost", duration: 90, type: 'good', chance: 0.8,
               description: "All XP gains +50%!",
               effect: { type: 'xpMultiplier', multiplier: 1.5 }
           },
           { // Positive
              id: 'luckyRolls', name: "Lucky Streak", duration: 45, type: 'good', chance: 0.5,
               description: "+5% chance multiplier for Epic+ items!",
               effect: { type: 'rarityWeightMultiplier', minRarity: 'Epic', multiplier: 1.05 }
           },
          { // Positive
              id: 'infusionDiscount', name: "Infusion Insight", duration: 120, type: 'good', chance: 0.6,
              description: "Infusion costs reduced by 10%!",
              effect: { type: 'infusionCostMultiplier', multiplier: 0.9 }
          },
          { // Positive
              id: 'fastForward', name: "Time Flux", duration: 30, type: 'good', chance: 0.4,
               description: "Anomaly checks happen 5x faster!",
               effect: { type: 'anomalyTickMultiplier', multiplier: 5.0 } // Affects its own check speed!
          },
           { // Neutral/Mixed
              id: 'commonFocus', name: "Common Focus", duration: 60, type: 'neutral', chance: 0.7,
              description: "Common item chance +20%, all others slightly reduced.",
              effect: { type: 'specificRarityWeightAdjustment', rarity: 'Common', percentageChange: 20 } // Will require logic to slightly decrease others
           },
           { // Negative
               id: 'shardDrain', name: "Shard Drain", duration: 60, type: 'bad', chance: 0.5,
               description: "Gain 50% fewer Shards.",
               effect: { type: 'shardMultiplier', multiplier: 0.5 }
           },
            { // Negative
               id: 'expensiveRolls', name: "Costly Venture", duration: 90, type: 'bad', chance: 0.4,
               description: "Base roll cost +1 Shard.", // Requires implementing roll cost
               effect: { type: 'rollCostFlatIncrease', amount: 1 }
            },
           { // Negative
              id: 'unluckyStreak', name: "Unlucky Phase", duration: 45, type: 'bad', chance: 0.3,
              description: "Epic+ items are 10% less likely.",
               effect: { type: 'rarityWeightMultiplier', minRarity: 'Epic', multiplier: 0.9 }
           },
       ];

       // --- Achievements V4 (Add Crafting/Anomaly/Ascension goals) ---
       const achievements = [
           // --- Existing Rolling / Collection / Leveling / Set Achievements (Keep V3 ones) ---
           // Example V3 achievement (keep similar ones)
           { id: 'roll100', name: 'Dedicated Roller', description: 'Roll 100 times.', type: 'rolls', target: 100, icon: 'fa-solid fa-dice-d20', reward: { type: 'guaranteedRoll', rarity: 'Rare', amount: 1 } },
           { id: 'collectAllCommon', name: 'Common Master', description: `Collect all ${totalItemCounts['Common']} unique Common items.`, type: 'uniqueCount', rarity: 'Common', target: totalItemCounts['Common'], icon: 'fa-solid fa-boxes-stacked', reward: { type: 'xp', amount: 100 } },
           { id: 'reachLevel10', name: 'Double Digits', description: 'Reach Player Level 10.', type: 'playerLevel', target: 10, icon: 'fa-solid fa-award', reward: { type: 'guaranteedRoll', rarity: 'Rare', amount: 1, xp: 150 } },
           { id: 'complete1Set', name: 'Set Starter', description: 'Complete 1 Collection Set.', type: 'setsCompleted', target: 1, icon: 'fa-solid fa-puzzle-piece', reward: { type: 'shards', amount: 50 } },
            { id: 'collect1Mythic', name: 'Mythic Moment', description: 'Collect your first Mythic item.', type: 'uniqueCount', rarity: 'Mythic', target: 1, icon: 'fa-solid fa-hat-wizard', reward: { type: 'shards', amount: 2000, xp: 500 } },

           // --- V4 New Achievements ---
            { id: 'craft1Item', name: 'First Craft', description: 'Successfully craft any item.', type: 'craftsMade', target: 1, icon: 'fa-solid fa-hammer', reward: { type: 'xp', amount: 50 } },
            { id: 'craft10Items', name: 'Budding Crafter', description: 'Craft 10 items.', type: 'craftsMade', target: 10, icon: 'fa-solid fa-toolbox', reward: { type: 'shards', amount: 100 } },
           { id: 'craftRareItem', name: 'Skilled Crafting', description: 'Craft an item of Rare rarity or higher.', type: 'craftRarity', minRarity: 'Rare', target: 1, icon: 'fa-solid fa-star', reward: { type: 'xp', amount: 150 } },
            { id: 'craftGuaranteedRoll', name: 'Luck Smith', description: 'Craft a Guaranteed Roll charm.', type: 'craftSpecificType', outputType: 'guaranteedRoll', target: 1, icon: 'fa-solid fa-magic-wand-sparkles', reward: { type: 'shards', amount: 200 } },

           { id: 'encounterAnomaly', name: 'What Was That?', description: 'Encounter your first Anomaly.', type: 'anomaliesEncountered', target: 1, icon: 'fa-solid fa-bolt', reward: { type: 'xp', amount: 30 } },
           { id: 'encounter5Anomalies', name: 'Anomaly Magnet', description: 'Encounter 5 different Anomalies.', type: 'uniqueAnomaliesEncountered', target: 5, icon: 'fa-solid fa-burst', reward: { type: 'shards', amount: 150 } },
            { id: 'surviveNegativeAnomaly', name: 'Weathered the Storm', description: 'Have a negative Anomaly expire.', type: 'negativeAnomaliesSurvived', target: 1, icon: 'fa-solid fa-shield-halved', reward: { type: 'xp', amount: 100 } },

            { id: 'gainFirstEssence', name: 'Taste of Power', description: 'Gain your first point of Ascension Essence.', type: 'totalEssenceEarned', target: 1, icon: 'fa-solid fa-seedling', reward: null }, // Essence is the reward really
            { id: 'ascend1', name: 'First Steps Beyond', description: 'Ascend for the first time.', type: 'ascensions', target: 1, icon: 'fa-solid fa-person-hiking', reward: { type: 'shards', amount: 1000 } }, // Welcome back bonus
           // Add achievements for reaching higher Ascension counts or total Essence milestones

          // IMPORTANT: Make sure 'target' and calculation logic in checkAchievements match these types
       ];

      // --- Collection Sets V4 (No major changes needed, bonuses interact with new systems) ---
       const collectionSets = [
           { id: 'forestBasics', name: 'Forest Basics', icon: 'fa-solid fa-tree', items: ['Twisted Twig', 'Faded Leaf', 'Cracked Acorn', 'Chunk of Bark', 'Pine Needle'], rewardDesc: "+2% Common Item Weight", bonus: { type: 'rarityWeightBonus', rarity: 'Common', percentage: 2 } },
           { id: 'shorelineFinds', name: 'Shoreline Finds', icon: 'fa-solid fa-water', items: ['Common Seashell', 'Gravel Bit', 'Bottle Glass Shard', 'Sea Glass (Green)', 'Smooth River Stone'], rewardDesc: "+5 Shards per Legendary/Mythic Roll", bonus: { type: 'shardBonusOnRoll', rarities: ['Legendary', 'Mythic'], amount: 5 } }, // Buffed slightly
           { id: 'luckyCharms', name: 'Lucky Charms', icon: 'fa-solid fa-clover', items: ['Four-Leaf Clover', 'Polished Acorn', 'Enchanted Pebble', 'Golden Acorn', 'Phoenix Down (Small)'], rewardDesc: "+0.1% Epic Item Weight", bonus: { type: 'rarityWeightBonus', rarity: 'Epic', percentage: 0.1 } },
           { id: 'rareGems', name: 'Rare Gems & Stones', icon: 'fa-solid fa-gem', items: ['Small Sapphire', 'Obsidian Shard', 'Quartz Pebble', 'Opal Chip', 'Crystal Shard'], rewardDesc: "+5% Item Sell Value", bonus: { type: 'sellValueBonus', percentage: 5 } },
           { id: 'arcaneFragments', name: 'Arcane Fragments', icon: 'fa-solid fa-wand-sparkles', items: ['Humming Rune Stone', 'Fairy Wing Dust', 'Rune Tablet Fragment', 'Aetherium Crystal', 'Philosopher\'s Dewdrop'], rewardDesc: "+10% XP Bonus from Achievements", bonus: { type: 'xpBonusPercent', source: 'achievement', percentage: 10 } },
           { id: 'mythicalRemnants', name: 'Mythical Remnants', icon: 'fa-solid fa-dragon', items: ['Dragon Tear', 'Griffin Feather', 'Manticore Spike', 'Prismatic Dragon Scale', 'Tiamat\'s Scale Fragment'], rewardDesc: "+0.05% Mythic Item Weight", bonus: { type: 'rarityWeightBonus', rarity: 'Mythic', percentage: 0.05 } },
           { id: 'unusualLife', name: 'Unusual Life', icon: 'fa-solid fa-dna', items: ['Small Worm', 'Dust Bunny', 'Polished Amber (w/ Insect)', 'Giant\'s Tooth', 'The Never-Ending Bloom'], rewardDesc: "+1 XP per roll", bonus: { type: 'xpBonus', source: 'roll', amount: 1 } },
           { id: 'elementalEssences', name: 'Elemental Essences', icon: 'fa-solid fa-flask', items: ['Essence of Fire', 'Shadow Essence', 'Ice Wyrm Scale', 'Lightning-Struck Bark', 'Aetherium Crystal'], rewardDesc: "+1 Shard per roll", bonus: { type: 'shardBonusOnRoll', rarities: rarities, amount: 1 } },
           { id: 'timeKeepers', name: 'Time Keepers', icon: 'fa-solid fa-clock', items: ['Miniature Hourglass', 'Pocket Watch (Stopped)', 'Timeless Sandglass', 'Chronoscrystal Fragment'], rewardDesc: "+5% Anomaly Duration", bonus: { type: 'anomalyDurationMultiplier', value: 1.05 } }, // Changed bonus to be active
       ];


      // --- Game State V4 ---
      let inventory = {};
      let stats = {}; // Initialized in resetGameState
      let playerAchievements = {};
      let completedSets = {};
      let currentInventorySort = 'rarity_desc';
      let currentInventoryFilter = 'all';
      let selectedItemForInfusion = null;
      let isRolling = false;
      let toastTimeout;
      let activeAnomalies = {}; // { anomalyId: { anomaly: {...}, expires: timestamp }, ... }
      let anomalyIntervalId = null;
      let canAscend = false; // Flag to check if ascension conditions met

      // --- DOM Elements Cache V4 (Add Crafting/Anomaly/Ascension elements) ---
      const DOMElements = {
          rollButton: document.getElementById('rollButton'),
          rollCostDisplay: document.getElementById('rollCostDisplay'), // To show potential cost
          guaranteedRollButton: document.getElementById('guaranteedRollButton'),
          resultDisplayWrapper: document.getElementById('resultDisplayWrapper'),
          resultDisplay: document.getElementById('resultDisplay'),
          inventoryList: document.getElementById('inventoryList'),
          emptyInventoryMsg: document.getElementById('emptyInventory'),
          inventoryCountDisplay: document.getElementById('inventoryCount'),
          inventorySort: document.getElementById('inventorySort'),
          inventoryFilter: document.getElementById('inventoryFilter'),

          // Stat displays
          totalRollsStat: document.getElementById('totalRollsStat'),
          commonStat: document.getElementById('commonStat'), uncommonStat: document.getElementById('uncommonStat'),
          rareStat: document.getElementById('rareStat'), epicStat: document.getElementById('epicStat'),
          legendaryStat: document.getElementById('legendaryStat'), mythicStat: document.getElementById('mythicStat'),
          completedSetsStat: document.getElementById('completedSetsStat'),
          achievementsUnlockedStat: document.getElementById('achievementsUnlockedStat'),
          maxInfusionStat: document.getElementById('maxInfusionStat'),
          totalShardsEarnedStat: document.getElementById('totalShardsEarnedStat'),
          itemsCraftedStat: document.getElementById('itemsCraftedStat'), // New
          anomaliesEncounteredStat: document.getElementById('anomaliesEncounteredStat'), // New
          totalEssenceEarnedStat: document.getElementById('totalEssenceEarnedStat'), // New

          // Achievements / Sets / Toast / Header Stats (Mostly same IDs)
          achievementList: document.getElementById('achievementList'), loadingAchievementsMsg: document.getElementById('loadingAchievements'),
          setList: document.getElementById('setList'), loadingSetsMsg: document.getElementById('loadingSets'),
          toastElement: document.getElementById('toast'),
          playerShards: document.getElementById('playerShards'), playerLevel: document.getElementById('playerLevel'),
          playerXP: document.getElementById('playerXP'), xpToNextLevel: document.getElementById('xpToNextLevel'),
          playerXPBar: document.getElementById('playerXPBar'),

          // Infusion Tab
          infuseSelectionList: document.getElementById('infuseSelectionList'), emptyInfuseList: document.getElementById('emptyInfuseList'),
          infusionDetails: document.getElementById('infusionDetails'), infuseItemButton: document.getElementById('infuseItemButton'),
          infuseButtonCost: document.getElementById('infuseButtonCost'),

          // Crafting Tab
          recipeList: document.getElementById('recipeList'), loadingRecipes: document.getElementById('loadingRecipes'),

          // Anomaly Display
          anomalyStatus: document.getElementById('anomalyStatus'),

          // Ascension Elements
          essenceDisplay: document.getElementById('essenceDisplay'), playerEssence: document.getElementById('playerEssence'),
          ascendButton: document.getElementById('ascendButton'), essenceOnAscend: document.getElementById('essenceOnAscend'),
          ascensionTabButton: document.querySelector('[data-tab="ascension"]'), // Need the tab button itself
          ascensionTabContent: document.getElementById('tabContent-ascension'),

          // Tabs
          tabs: document.querySelectorAll('.tab-button'), tabContents: document.querySelectorAll('.tab-content'),

          // Footer / Cumulative Effects
          resetDataButton: document.getElementById('resetDataButton'),
          cumulativeEffectsDisplay: document.getElementById('cumulativeEffectsDisplay'),
      };

      // ========================================================================
      // --- Utility Functions ---
      // ========================================================================
      function formatNumber(num) { /* ... (same as V3) ... */ if (num === undefined || num === null) return '0'; return num.toLocaleString(); }
      function getItemRarityIndex(itemName) { /* ... (same as V3) ... */ const itemData = inventory[itemName]?.item || items.find(i => i.name === itemName); if (!itemData || !rarityConfig[itemData.rarity]) return -1; return rarityConfig[itemData.rarity].index ?? -1; }

      // ========================================================================
      // --- Core Game Mechanics (XP, Shards, Bonuses) ---
      // ========================================================================

      // --- XP & Leveling --- (Handles multipliers now)
      function getXPForNextLevel(level) { return Math.floor(BASE_XP_PER_LEVEL * Math.pow(XP_LEVEL_MULTIPLIER, level - 1)); }
      function addXP(baseAmount, source = 'misc') {
          if (baseAmount <= 0) return;
          let currentMultiplier = getEffectiveStatMultiplier('xpMultiplier'); // Includes anomalies, items, sets etc.
          let totalAmount = Math.floor(baseAmount * currentMultiplier);

          // Add flat bonuses after multiplication
          totalAmount += calculateCumulativeItemEffects().xpPerRollFlat || 0; // Add flat bonuses from items if source is 'roll'
          // Potentially add flat bonuses from sets/anomalies too if needed

          if (totalAmount <= 0) return;

          stats.xp += totalAmount;
          console.log(`Gained ${baseAmount} XP (-> ${totalAmount} total w/ ${((currentMultiplier-1)*100).toFixed(1)}% bonus) from ${source}. Current: ${formatNumber(stats.xp)}`);

          let xpForNext = getXPForNextLevel(stats.level);
          let leveledUp = false;
          while (stats.xp >= xpForNext) {
              // Grant reward before potentially modifying stats in checkAchievements
              const levelUpReward = { type: 'shards', amount: stats.level * 10 + 50 }; // Increased level up reward
              grantReward(levelUpReward, `Level ${stats.level + 1} Reached`);

              stats.xp -= xpForNext;
              stats.level++;
              leveledUp = true;
              console.log(`Level Up! Reached Level ${stats.level}`);
              showToast(`Level Up! Reached Level ${stats.level}!`, 'success');
              checkAscensionUnlock(); // Check if ascension is now possible
              checkAchievements(); // Check level achievements
              xpForNext = getXPForNextLevel(stats.level); // Update for multi-level up
          }
          if (leveledUp || source !== 'load') { updatePlayerStatsUI(); }
      }

      // --- Shard Management --- (Handles multipliers)
      function addShards(baseAmount, reason = "unknown") {
          if (baseAmount > 0) {
               let currentMultiplier = getEffectiveStatMultiplier('shardMultiplier'); // Get current shard multiplier
               let finalAmount = Math.floor(baseAmount * currentMultiplier);
               stats.shards += finalAmount;
               stats.totalShardsEarned += finalAmount; // Track *actual* earned for achievements
               console.log(`+${formatNumber(baseAmount)} Shards (-> ${formatNumber(finalAmount)} w/ mult) from ${reason}. Total: ${formatNumber(stats.shards)}`);
               updatePlayerStatsUI();
               checkAchievements();
               return true;
          } else if (baseAmount < 0) {
              // Costs generally aren't affected by gain multipliers
               const cost = Math.abs(baseAmount);
              if (stats.shards >= cost) {
                   stats.shards -= cost;
                   console.log(`-${formatNumber(cost)} Shards spent on ${reason}. Remaining: ${formatNumber(stats.shards)}`);
                   updatePlayerStatsUI();
                   return true; // Successful spend
               } else {
                   console.log(`Failed to spend ${formatNumber(cost)} Shards on ${reason}. Only have ${formatNumber(stats.shards)}`);
                   showToast(`Not enough Shards! Need ${formatNumber(cost)}.`, 'warning');
                   return false; // Failed spend
               }
          }
           return true; // Zero amount has no effect
      }


      // --- Passive Item Effect Calculation ---
      let cachedItemEffects = {}; // Cache calculated effects
      let inventoryChangedSinceLastEffectCalc = true; // Flag to force recalc

      function calculateCumulativeItemEffects() {
          if (!inventoryChangedSinceLastEffectCalc) {
              return cachedItemEffects;
          }

          const effects = {
               shardPerRollFlat: 0, shardPerRollPercent: 0, shardBonusCommonRoll: 0,
               xpPerRollFlat: 0, xpPerRollPercent: 0,
               sellValuePercent: 0, infusionCostPercent: 0,
               anomalyChanceMultiplier: 1, anomalyDurationMultiplier: 1, anomalyTickIntervalMultiplier: 1,
               anomalyNegativeEffectResist: 0,
               commonRarityWeightPercent: 0, uncommonRarityWeightPercent: 0, rareRarityWeightPercent: 0,
               epicRarityWeightPercent: 0, legendaryRarityWeightPercent: 0, mythicRarityWeightPercent: 0,
               allRarityWeightPercentAboveCommon: 0, // Mythic effect example
               setBonusMultiplier: 1, // Multiplier for SET bonuses themselves
              rerollBelowEpicChance: 0,
              // Add other effect types here
          };

          for (const itemName in inventory) {
              const itemData = inventory[itemName];
              const itemDef = items.find(i => i.name === itemName); // Get full definition
               if (itemDef && itemDef.effect) {
                  const effect = itemDef.effect;
                   const count = itemData.count; // Effects generally scale with count
                  if (effects.hasOwnProperty(effect.type)) {
                       // Basic linear scaling with count for most effects
                      if (typeof effect.value === 'number') {
                           effects[effect.type] += effect.value * count;
                       }
                      // Handle multipliers specially - they often shouldn't stack additively based on count
                      else if (effect.type.includes('Multiplier') && effect.value !== 1) {
                           // For multipliers, maybe apply diminishing returns or just apply base effect once?
                           // Let's apply the multiplier effect from ONE item for now, regardless of count, to prevent wild scaling.
                           // Example: Owning 10 mushrooms doesn't give 1.02^10 multiplier.
                           // A better approach might use logs or caps, but let's keep it simple: apply only if current multiplier is still 1.
                           if (effects[effect.type] === 1) { // Only apply if not already modified by another item of this type
                                effects[effect.type] = effect.value;
                            } else {
                                // Optionally apply a smaller bonus for duplicates
                                // effects[effect.type] *= (1 + (effect.value - 1) * 0.1); // e.g., 10% of effect for duplicates
                            }
                      }
                   } else {
                      console.warn(`Item ${itemName} has unknown effect type: ${effect.type}`);
                   }
              }
          }

           // Special handling for percentage-based weight adjustments
           // These modify the base weight values used in getEffectiveRarityConfig
           const rarityWeightAdjustments = {};
           rarities.forEach(r => {
               rarityWeightAdjustments[r] = effects[`${r.toLowerCase()}RarityWeightPercent`] || 0;
               if (r !== 'Common' && effects.allRarityWeightPercentAboveCommon) {
                   rarityWeightAdjustments[r] += effects.allRarityWeightPercentAboveCommon;
               }
           });
           effects.rarityWeightAdjustments = rarityWeightAdjustments; // Store calculated adjustments


          cachedItemEffects = effects;
          inventoryChangedSinceLastEffectCalc = false;
           updateCumulativeEffectsUI(effects); // Update the footer display
          console.log("Calculated cumulative item effects:", effects);
          return effects;
      }

       function updateCumulativeEffectsUI(effects) {
           let parts = [];
           if (effects.shardPerRollFlat > 0) parts.push(`+${effects.shardPerRollFlat.toFixed(2)}âœ¨/roll`);
           if (effects.shardPerRollPercent > 0) parts.push(`+${effects.shardPerRollPercent.toFixed(1)}% âœ¨/roll`);
           if (effects.xpPerRollFlat > 0) parts.push(`+${effects.xpPerRollFlat.toFixed(1)} XP/roll`);
           if (effects.xpPerRollPercent > 0) parts.push(`+${effects.xpPerRollPercent.toFixed(1)}% XP/roll`);
           if (effects.sellValuePercent > 0) parts.push(`+${effects.sellValuePercent.toFixed(1)}% Sell Val`);
           if (effects.infusionCostPercent < 0) parts.push(`${effects.infusionCostPercent.toFixed(1)}% Infuse Cost`);
           if (effects.anomalyChanceMultiplier !== 1) parts.push(`${((effects.anomalyChanceMultiplier-1)*100).toFixed(0)}% Anomaly Rate`);
           // Add more effect displays here...

          DOMElements.cumulativeEffectsDisplay.textContent = parts.length > 0 ? parts.join(', ') : "None";
           DOMElements.cumulativeEffectsDisplay.setAttribute('data-tooltip', parts.length > 0 ? parts.join('\n') : 'No active item effects');
       }

      // --- Applying Bonuses (Combined Logic) ---
      // Gets the effective multiplier for a stat after considering items, sets, anomalies
      function getEffectiveStatMultiplier(statType) { // e.g., 'shardMultiplier', 'xpMultiplier', 'infusionCostMultiplier'
           let baseMultiplier = 1.0;
           const itemEffects = calculateCumulativeItemEffects(); // Uses cache if possible
           const setBonusEffectMultiplier = itemEffects.setBonusMultiplier || 1; // Get potential meta-multiplier from items

           // 1. Base Item Effects
           // Note: percentage bonuses from items are usually added to multipliers, flat bonuses handled separately
           if (statType === 'shardMultiplier' && itemEffects.shardPerRollPercent) baseMultiplier += (itemEffects.shardPerRollPercent / 100);
           if (statType === 'xpMultiplier' && itemEffects.xpPerRollPercent) baseMultiplier += (itemEffects.xpPerRollPercent / 100);
           if (statType === 'infusionCostMultiplier' && itemEffects.infusionCostPercent) baseMultiplier += (itemEffects.infusionCostPercent / 100); // Note: cost reduction is negative %

          // 2. Add Set Bonuses (potentially modified by item effects)
          Object.keys(completedSets).forEach(setId => {
              const set = collectionSets.find(s => s.id === setId);
               if (!set || !set.bonus) return;
               const bonus = set.bonus;
              let bonusValue = 0;
              if (bonus.type === 'shardMultiplier' && statType === 'shardMultiplier') bonusValue = (bonus.multiplier || 1) - 1;
               if (bonus.type === 'xpBonusPercent' && statType === 'xpMultiplier') bonusValue = (bonus.percentage || 0) / 100; // Convert percentage to additive modifier
               // Add other set bonus checks affecting multipliers...
               if (bonusValue !== 0) {
                  baseMultiplier += (bonusValue * setBonusEffectMultiplier); // Apply set bonus, modified by item effects
               }
          });

          // 3. Add Anomaly Effects (use direct multipliers from anomaly def)
          for (const id in activeAnomalies) {
              const anomalyEffect = activeAnomalies[id].anomaly.effect;
              if (anomalyEffect && anomalyEffect.type === statType && anomalyEffect.multiplier) {
                   baseMultiplier *= anomalyEffect.multiplier; // Anomalies often multiply the whole stack
              }
           }

          return Math.max(0, baseMultiplier); // Ensure multiplier doesn't go negative
       }

      // Similar function needed for flat bonuses or direct modifications if they become complex


      // ========================================================================
      // --- Random Item Generation V4 --- (Applies Item Effects)
      // ========================================================================
       function getEffectiveRarityConfig() {
           let currentConfig = JSON.parse(JSON.stringify(rarityConfig)); // Deep copy
           const itemEffects = calculateCumulativeItemEffects(); // Get cumulative weight adjustments

          // Apply Item Effect Weight Adjustments first
          if (itemEffects.rarityWeightAdjustments) {
               for(const rarity in itemEffects.rarityWeightAdjustments) {
                   if (currentConfig[rarity]) {
                        const baseWeight = rarityConfig[rarity].weight; // Adjust relative to BASE weight
                       const changePercent = itemEffects.rarityWeightAdjustments[rarity];
                       const weightChange = baseWeight * (changePercent / 100);
                       currentConfig[rarity].weight = Math.max(0, currentConfig[rarity].weight + weightChange); // Apply change, ensure non-negative
                       if (weightChange !== 0) console.log(`Item Effect: Rarity Weight Adj for ${rarity}: ${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(1)}% -> new weight ${currentConfig[rarity].weight.toFixed(2)}`);
                   }
              }
           }


          // Apply Set Bonus Weight Adjustments (Using BASE total weight for consistency)
          Object.keys(completedSets).forEach(setId => {
              const set = collectionSets.find(s => s.id === setId);
              if (set && set.bonus && set.bonus.type === 'rarityWeightBonus' && currentConfig[set.bonus.rarity]) {
                   const weightIncrease = totalBaseWeight * (set.bonus.percentage / 100); // % of TOTAL base weight
                  currentConfig[set.bonus.rarity].weight = Math.max(0, currentConfig[set.bonus.rarity].weight + weightIncrease);
                  console.log(`Set Bonus (${set.name}): Rarity Weight Adj for ${set.bonus.rarity}: +${weightIncrease.toFixed(2)} -> new weight ${currentConfig[set.bonus.rarity].weight.toFixed(2)}`);
              }
           });


          // Apply Anomaly Weight Adjustments (usually multiplicative or large flat changes)
          for (const id in activeAnomalies) {
              const anomalyEffect = activeAnomalies[id].anomaly.effect;
               if (anomalyEffect && anomalyEffect.type === 'rarityWeightMultiplier' && anomalyEffect.minRarity) {
                   const minIndex = rarityConfig[anomalyEffect.minRarity]?.index ?? -1;
                  rarities.forEach(r => {
                       if (currentConfig[r]?.index >= minIndex) {
                          currentConfig[r].weight *= anomalyEffect.multiplier;
                      }
                  });
                   console.log(`Anomaly (${activeAnomalies[id].anomaly.name}): Rarity Multiplier x${anomalyEffect.multiplier} for ${anomalyEffect.minRarity}+`);
               } else if (anomalyEffect && anomalyEffect.type === 'specificRarityWeightAdjustment') {
                    const rarity = anomalyEffect.rarity;
                    if(currentConfig[rarity]) {
                        const baseWeight = rarityConfig[rarity].weight;
                        const weightChange = baseWeight * (anomalyEffect.percentageChange / 100);
                        currentConfig[rarity].weight = Math.max(0, currentConfig[rarity].weight + weightChange);
                        // Optional: Slightly decrease *other* weights to compensate? Or just let total weight float. Let it float for now.
                        console.log(`Anomaly (${activeAnomalies[id].anomaly.name}): Specific Rarity Adj for ${rarity}: ${weightChange>=0?'+':''}${weightChange.toFixed(2)} -> new weight ${currentConfig[rarity].weight.toFixed(2)}`);
                    }
               }
          }


          // --- Weight Normalization --- (Optional but recommended)
          const currentTotalWeight = Object.values(currentConfig).reduce((sum, r) => sum + r.weight, 0);
          if (currentTotalWeight > 0 && Math.abs(currentTotalWeight - totalBaseWeight) > 0.01) {
              const factor = totalBaseWeight / currentTotalWeight;
               // console.log(`Normalizing rarity weights by factor: ${factor.toFixed(4)} (CurrentTotal: ${currentTotalWeight.toFixed(2)}, BaseTotal: ${totalBaseWeight})`);
              for (const rarity in currentConfig) { currentConfig[rarity].weight *= factor; }
           } else if (currentTotalWeight <= 0) {
              console.error("CRITICAL: Total rarity weight zero or negative. Reverting to base config.");
              return JSON.parse(JSON.stringify(rarityConfig));
           }

           // Log effective chances after all adjustments and normalization
           console.log("Effective Rarity Chances:");
           const finalTotalWeight = Object.values(currentConfig).reduce((sum, r) => sum + r.weight, 0);
           rarities.forEach(r => {
                if (finalTotalWeight > 0) console.log(`  ${r}: ${(currentConfig[r].weight / finalTotalWeight * 100).toFixed(2)}%`);
           });


          return currentConfig;
       }

       function getRandomItem(minRarityName = 'Common') { /* ... (Selection logic remains similar to V3, but USES getEffectiveRarityConfig) ... */
              const effectiveConfig = getEffectiveRarityConfig();
              const minRarityIndex = rarityConfig[minRarityName]?.index ?? 0;
              const allowedRarities = rarities.filter(r => effectiveConfig[r]?.index >= minRarityIndex);
              const filteredConfig = allowedRarities.reduce((acc, rarity) => { if (effectiveConfig[rarity]) acc[rarity] = effectiveConfig[rarity]; return acc; }, {});
              const totalWeight = Object.values(filteredConfig).reduce((sum, rarity) => sum + Math.max(0, rarity.weight), 0); // Ensure non-negative weight

              if (totalWeight <= 0) { /* ... (Fallback logic as in V3) ... */
                   console.warn(`No weight found for allowed rarities >= ${minRarityName}, defaulting to ${minRarityName}.`);
                   const fallbackItems = items.filter(item => item.rarity === minRarityName);
                   if (fallbackItems.length > 0) return fallbackItems[Math.floor(Math.random() * fallbackItems.length)];
                   const commonItems = items.filter(item => item.rarity === 'Common'); return commonItems.length > 0 ? commonItems[Math.floor(Math.random() * commonItems.length)] : null;
              }
              let randomNum = Math.random() * totalWeight; let selectedRarity = null;
               for (const rarity in filteredConfig) { const weight = Math.max(0, filteredConfig[rarity].weight); if (weight > 0 && randomNum < weight) { selectedRarity = rarity; break; } randomNum -= weight; }
               if (!selectedRarity) selectedRarity = allowedRarities[allowedRarities.length - 1];
               const itemsOfRarity = items.filter(item => item.rarity === selectedRarity);
               if (itemsOfRarity.length > 0) { const randomIndex = Math.floor(Math.random() * itemsOfRarity.length); return itemsOfRarity[randomIndex]; }
               else { /* ... (Critical Fallback logic as in V3) ... */
                   console.error(`CRITICAL: No items found for selected rarity: ${selectedRarity} (min: ${minRarityName}). Trying absolute fallback.`); const commonItems = items.filter(item => item.rarity === 'Common'); return commonItems.length > 0 ? commonItems[Math.floor(Math.random() * commonItems.length)] : null;
               }
       }


      // ========================================================================
      // --- Inventory Management V4 ---
      // ========================================================================
       function addToInventory(item) {
          let isNewUnique = false;
          if (inventory[item.name]) { inventory[item.name].count++; }
          else { isNewUnique = true; inventory[item.name] = { item: { name: item.name, rarity: item.rarity, icon: item.icon, description: item.description }, count: 1, level: 1 }; }

          inventoryChangedSinceLastEffectCalc = true; // Mark effects cache dirty

          if (isNewUnique) {
              const xpSource = `newItem-${item.rarity}`;
              addXP(rarityConfig[item.rarity]?.xpOnRoll * 5 || 10, xpSource); // More XP for finding new unique items based on rarity
               checkSetCompletion(item.name); // Check sets only when a new unique item is added
               checkAscensionUnlock(); // Check if the final item needed was collected
               checkAchievements(); // Check collection achievements
           }
       }

      // ========================================================================
      // --- Selling & Infusion V4 --- (Applies relevant multipliers)
      // ========================================================================
       function getSellValue(itemData) {
          if (!itemData || !itemData.item) return 0;
           const baseValue = rarityConfig[itemData.item.rarity]?.sellValue || 0;
           // Slightly higher level bonus: Base * (1 + 0.25 * (Level - 1))
          const levelMultiplier = 1 + 0.25 * (itemData.level - 1);
          let value = baseValue * levelMultiplier;

          // Apply combined % bonuses from items, sets, anomalies
          let bonusPercent = (getEffectiveStatMultiplier('sellValueBonus') - 1) * 100; // Get multiplier, convert back to % additive
          value *= (1 + bonusPercent / 100);

          return Math.max(1, Math.floor(value));
      }
      function sellItem(itemName, amount = 1) { /* ... (Logic mostly same, but addShards now handles multipliers) ... */
           if (!inventory[itemName] || inventory[itemName].count < amount) { console.error(`Attempted to sell ${amount}x ${itemName}, but only have ${inventory[itemName]?.count ?? 0}.`); showToast(`Not enough ${itemName} to sell!`, 'warning'); return; }
           const itemData = inventory[itemName]; const singleSellValue = getSellValue(itemData); const totalSellValue = singleSellValue * amount;
           itemData.count -= amount;
           addShards(totalSellValue, `sold ${amount}x ${itemName}`); // addShards handles multipliers now
           if (itemData.count === 0) { delete inventory[itemName]; if (selectedItemForInfusion === itemName) { selectItemForInfusion(null); } }
           console.log(`Sold ${amount}x ${itemName} for ${formatNumber(totalSellValue)} Shards.`);
           inventoryChangedSinceLastEffectCalc = true; // Inventory changed
           updateInventoryDisplay(); updateInfusionSelectionList(); if (selectedItemForInfusion === itemName) updateInfusionUI(itemName);
           checkAscensionUnlock(); // Check if selling last item prevents ascension
          saveData();
      }
      function sellAllDuplicates(itemName) { /* ... (Same logic as V3) ... */ if (inventory[itemName] && inventory[itemName].count > 1) { const amountToSell = inventory[itemName].count - 1; sellItem(itemName, amountToSell); } else { showToast(`No duplicates of ${itemName} to sell.`, 'info'); } }


      function getInfusionCost(itemData) { /* ... (Applies multipliers) ... */
          if (!itemData || !itemData.item) return Infinity;
          const config = rarityConfig[itemData.item.rarity]; if (!config) return Infinity;
          const baseCost = config.infusionBaseCost || 10; const levelMultiplier = config.infusionLevelMult || 1.5;
          const currentLevel = itemData.level || 1;
          let cost = baseCost * Math.pow(levelMultiplier, currentLevel - 1);
          let costMultiplier = getEffectiveStatMultiplier('infusionCostMultiplier');
          cost *= costMultiplier; // Apply multiplicative cost changes (anomalies, items)
           return Math.max(1, Math.floor(cost));
      }
      function infuseItem(itemName) { /* ... (addShards now handles cost deduction; add XP for infusing) ... */
          const itemData = inventory[itemName]; if (!itemData) { showToast(`Item ${itemName} not found.`, 'error'); return; }
          const cost = getInfusionCost(itemData);
          if (addShards(-cost, `infuse ${itemName}`)) { // Attempt to spend shards
              itemData.level++; stats.maxInfusionLevel = Math.max(stats.maxInfusionLevel, itemData.level);
               addXP(rarityConfig[item.rarity].xpOnRoll * 2 || 5, 'infuse'); // XP scales with rarity infused
              console.log(`Infused ${itemName} to Lvl ${itemData.level} for ${formatNumber(cost)} Shards.`);
              showToast(`Infused ${itemName} to Lvl ${itemData.level}!`, 'success');
              inventoryChangedSinceLastEffectCalc = true; // Stats affecting item value changed maybe
              updatePlayerStatsUI(); updateInventoryDisplay(); updateInfusionUI(itemName); updateInfusionSelectionList();
              checkAchievements(); checkAscensionUnlock(); saveData();
          }
      }
       function canAffordInfusion(itemName) { /* ... (uses getInfusionCost) ... */ const itemData = inventory[itemName]; if (!itemData) return false; const cost = getInfusionCost(itemData); return stats.shards >= cost; }

      // ========================================================================
      // --- Set Completion V4 --- (Applies item setBonusMultiplier)
      // ========================================================================
      function checkSetCompletion(newItemName = null) { /* ... (Logic mostly same, calls displaySets which reads effects) ... */
          let newlyCompletedSet = false;
          collectionSets.forEach(set => {
              if (!completedSets[set.id]) {
                   if (newItemName !== null && !set.items.includes(newItemName)) return;
                   const hasAllItems = set.items.every(setItemName => inventory[setItemName]?.count > 0);
                   if (hasAllItems) { completeSet(set.id); newlyCompletedSet = true; }
              }
          });
          if (newlyCompletedSet) {
               inventoryChangedSinceLastEffectCalc = true; // Bonuses may have changed
               updateStatsDisplay(); displaySets(); checkAchievements(); checkAscensionUnlock(); saveData();
          }
       }
       function completeSet(setId) { /* ... (Grant XP on complete) ... */
           if (!completedSets[setId]) { const set = collectionSets.find(s => s.id === setId); if (!set) return; completedSets[setId] = true; console.log(`Set Completed: ${set.name}`); showToast(`Set Complete: ${set.name}! Bonus active.`, 'success'); addXP(200 + (Object.keys(completedSets).length * 50), 'setComplete'); /* Bonus XP increases per set completed */ }
       }


      // ========================================================================
      // --- Crafting System V4 ---
      // ========================================================================
       function canCraft(recipeId) {
           const recipe = craftingRecipes.find(r => r.id === recipeId);
           if (!recipe) return false;
           return recipe.ingredients.every(ing => {
               const itemInInventory = inventory[ing.name];
               return itemInInventory && itemInInventory.count >= ing.count;
           });
       }

       function craftItem(recipeId) {
           const recipe = craftingRecipes.find(r => r.id === recipeId);
           if (!recipe) { console.error("Recipe not found:", recipeId); return; }

           if (!canCraft(recipeId)) {
               showToast("Not enough ingredients!", 'warning');
               return;
           }

           // Consume Ingredients
           recipe.ingredients.forEach(ing => {
               if (inventory[ing.name]) {
                   inventory[ing.name].count -= ing.count;
                   if (inventory[ing.name].count === 0) {
                       delete inventory[ing.name];
                        if (selectedItemForInfusion === ing.name) selectItemForInfusion(null); // Deselect if ingredient used up
                   }
               }
           });

          // Grant Output
           const output = recipe.output;
          let outputRarity = null;
           if (output.type === 'item') {
              // Grant item(s)
               const itemDef = items.find(i => i.name === output.name);
               if (itemDef) {
                   for (let i = 0; i < (output.amount || 1); i++) { addToInventory(itemDef); }
                  showToast(`Crafted ${output.amount || 1}x ${output.name}!`, 'success');
                   outputRarity = itemDef.rarity; // For achievement check
               } else { console.error("Crafted item definition not found:", output.name); }
           } else if (output.type === 'shards') {
               addShards(output.amount, `craft: ${recipe.name}`);
               showToast(`Crafted +${formatNumber(output.amount)} Shards!`, 'success');
           } else if (output.type === 'xp') {
               addXP(output.amount, `craft: ${recipe.name}`);
               showToast(`Crafted +${formatNumber(output.amount)} XP!`, 'success');
           } else if (output.type === 'guaranteedRoll') {
               const rarity = output.rarity || 'Uncommon';
               stats.guaranteedRareRolls += output.amount || 1; // Using the same stat for simplicity, name is legacy
              updateGuaranteedRollButton();
               showToast(`Crafted ${output.amount || 1}x Guaranteed ${rarity}+ Roll Charm!`, 'success');
               checkAchievements('craftSpecificType', output.type); // Check craft achievement by type
           }
           // Add more output types if needed

          stats.itemsCrafted++; // Increment crafting stat

           inventoryChangedSinceLastEffectCalc = true; // Inventory changed
           updateInventoryDisplay();
           updateCraftingUI(); // Update recipe availability visuals
           updateInfusionSelectionList(); // Items might have been removed/added
           checkAchievements('craftsMade'); // Check total crafts achievement
           if (outputRarity) checkAchievements('craftRarity', outputRarity); // Check craft rarity achievement
           checkAscensionUnlock(); // Check if ingredients needed for ascension were used up
          saveData();
       }

       function displayCraftingRecipes() {
          const list = DOMElements.recipeList;
          const loadingMsg = DOMElements.loadingRecipes;
          list.innerHTML = '';
          loadingMsg.style.display = 'none';

          const availableRecipes = craftingRecipes.filter(r => !r.unlockLevel || stats.level >= r.unlockLevel);

          if (availableRecipes.length === 0) {
              list.innerHTML = '<p class="text-gray-500 italic col-span-full text-center">Reach higher levels to unlock recipes.</p>';
              return;
          }

          availableRecipes.forEach(recipe => {
              const craftable = canCraft(recipe.id);
              const recipeElement = document.createElement('div');
              recipeElement.className = `recipe flex flex-col justify-between ${craftable ? 'can-craft' : ''}`;

              let ingredientsHTML = recipe.ingredients.map(ing => {
                  const owned = inventory[ing.name]?.count || 0;
                  const needed = ing.count;
                   const itemDef = items.find(i => i.name === ing.name);
                   const config = itemDef ? rarityConfig[itemDef.rarity] : null;
                  const bgColor = config ? config.bgClass : 'bg-gray-200';
                   const textColor = config ? config.colorClass : 'text-gray-700';
                   const borderColor = config ? `var(--${textColor.replace('rarity-','').toLowerCase()}-border)` : '#d1d5db'; // Construct border color from var name
                  const missing = owned < needed;
                  return `<span class="recipe-item ${missing ? 'missing' : bgColor} ${textColor}" style="border-color: ${borderColor}" data-tooltip="${ing.name}: ${formatNumber(owned)}/${formatNumber(needed)}">${itemDef?.icon || '?'} x${formatNumber(needed)}</span>`;
              }).join(' ');

              let outputHTML = '';
               if (recipe.output.type === 'item') {
                   const itemDef = items.find(i => i.name === recipe.output.name);
                   const config = itemDef ? rarityConfig[itemDef.rarity] : null;
                   const bgColor = config ? config.bgClass : 'bg-gray-200';
                   const textColor = config ? config.colorClass : 'text-gray-700';
                   const borderColor = config ? `var(--${textColor.replace('rarity-','').toLowerCase()}-border)` : '#d1d5db';
                   outputHTML = `<span class="recipe-item ${bgColor} ${textColor}" style="border-color: ${borderColor}" data-tooltip="Result">${itemDef?.icon || '?'} x${recipe.output.amount || 1}</span> ${recipe.output.name}`;
               } else if (recipe.output.type === 'shards') {
                  outputHTML = `<span class="recipe-item bg-amber-100 text-amber-700 border-amber-300" data-tooltip="Result">âœ¨ x${formatNumber(recipe.output.amount)}</span> Shards`;
               } else if (recipe.output.type === 'xp') {
                  outputHTML = `<span class="recipe-item bg-green-100 text-green-700 border-green-300" data-tooltip="Result">ğŸ§  x${formatNumber(recipe.output.amount)}</span> XP`;
              } else if (recipe.output.type === 'guaranteedRoll') {
                  outputHTML = `<span class="recipe-item bg-blue-100 text-blue-700 border-blue-300" data-tooltip="Result">${recipe.icon || 'ğŸŒŸ'} x${recipe.output.amount || 1}</span> Guaranteed ${recipe.output.rarity}+ Roll`;
              }

              recipeElement.innerHTML = `
                  <div>
                       <h4 class="font-semibold text-gray-800 mb-1">${recipe.name} <span class="text-xl">${recipe.icon || ''}</span></h4>
                      <p class="text-xs text-gray-500 mb-2">${recipe.description || ''}</p>
                      <div class="text-sm mb-2">
                          <span class="font-medium text-gray-600">Needs:</span> ${ingredientsHTML}
                      </div>
                      <div class="text-sm">
                          <span class="font-medium text-gray-600">Yields:</span> ${outputHTML}
                       </div>
                  </div>
                  <button class="btn btn-success btn-xs mt-3 self-end craft-button" data-recipeid="${recipe.id}" ${!craftable ? 'disabled' : ''}>Craft</button>
               `;
              list.appendChild(recipeElement);
           });

          // Add event listeners for craft buttons
          list.querySelectorAll('.craft-button').forEach(button => {
              button.addEventListener('click', (e) => {
                   const recipeId = e.target.dataset.recipeid;
                  craftItem(recipeId);
               });
          });
      }

      // ========================================================================
      // --- Anomalies V4 ---
      // ========================================================================

      function triggerAnomalyCheck() {
           const baseChance = ANOMALY_BASE_CHANCE;
           let effectiveChance = baseChance * getEffectiveStatMultiplier('anomalyChanceMultiplier'); // Apply item/set bonuses

          // console.log(`Anomaly Check: Effective Chance ${effectiveChance.toFixed(4)}`);

           if (Math.random() < effectiveChance) {
              const possibleAnomalies = anomalies.filter(a => !activeAnomalies[a.id]); // Can't have duplicates active
              if (possibleAnomalies.length > 0) {
                   const randomIndex = Math.floor(Math.random() * possibleAnomalies.length);
                   startAnomaly(possibleAnomalies[randomIndex]);
               }
           }
       }

       function startAnomaly(anomaly) {
          console.log("Starting anomaly:", anomaly.name);
          const resistChance = calculateCumulativeItemEffects().anomalyNegativeEffectResist || 0;
          if (anomaly.type === 'bad' && Math.random() < resistChance) {
               showToast(`Resisted Anomaly: ${anomaly.name}!`, 'success');
               console.log(`Resisted negative anomaly ${anomaly.name} due to resist chance ${resistChance}.`);
               return; // Don't activate the negative effect
          }


           const durationMs = (anomaly.duration * 1000) * getEffectiveStatMultiplier('anomalyDurationMultiplier');
          const expires = Date.now() + durationMs;

          activeAnomalies[anomaly.id] = { anomaly: anomaly, expires: expires };
           stats.anomaliesEncountered++;
           if (!stats.uniqueAnomalies) stats.uniqueAnomalies = {};
           stats.uniqueAnomalies[anomaly.id] = true;


          showToast(`Anomaly Detected: ${anomaly.name}! ${anomaly.description}`, 'anomaly', 5000);
          displayActiveAnomalies();
          inventoryChangedSinceLastEffectCalc = true; // Anomaly might affect calculated values
           updateRollCostDisplay(); // If anomaly affects roll cost
           checkAchievements('anomaliesEncountered');
           checkAchievements('uniqueAnomaliesEncountered');
           saveData();

           // Schedule removal
           setTimeout(() => {
               endAnomaly(anomaly.id);
           }, durationMs);
      }

       function endAnomaly(anomalyId) {
           const endedAnomaly = activeAnomalies[anomalyId];
           if (endedAnomaly) {
              console.log("Ending anomaly:", endedAnomaly.anomaly.name);
               delete activeAnomalies[anomalyId];
               showToast(`Anomaly Ended: ${endedAnomaly.anomaly.name}.`, 'info');
               displayActiveAnomalies();
               inventoryChangedSinceLastEffectCalc = true; // Recalculate effective stats
               updateRollCostDisplay(); // Update potential cost display

              if (endedAnomaly.anomaly.type === 'bad') {
                   stats.negativeAnomaliesSurvived = (stats.negativeAnomaliesSurvived || 0) + 1;
                  checkAchievements('negativeAnomaliesSurvived');
               }
               saveData();
          }
       }

       function displayActiveAnomalies() {
           const statusDiv = DOMElements.anomalyStatus;
          statusDiv.innerHTML = '';
          const now = Date.now();

           Object.values(activeAnomalies).forEach(active => {
               const remaining = Math.ceil((active.expires - now) / 1000);
              if (remaining <= 0) return; // Skip if technically expired but timeout hasn't run yet

               const icon = document.createElement('span');
               const anomaly = active.anomaly;
               let iconClass = 'anomaly-neutral';
               if (anomaly.type === 'good') iconClass = 'anomaly-good';
               else if (anomaly.type === 'bad') iconClass = 'anomaly-bad';
               icon.className = `anomaly-icon ${iconClass}`;
               icon.setAttribute('data-tooltip', `${anomaly.name} (${remaining}s): ${anomaly.description}`);
              icon.textContent = anomaly.icon || (anomaly.type === 'good' ? 'âœ¨' : anomaly.type === 'bad' ? 'ğŸ’€' : 'ğŸ”§'); // Simple icons
               statusDiv.appendChild(icon);
           });
       }

       function startAnomalyTimer() {
          if (anomalyIntervalId) clearInterval(anomalyIntervalId); // Clear existing timer
          const tickInterval = ANOMALY_TICK_INTERVAL * (getEffectiveStatMultiplier('anomalyTickIntervalMultiplier') || 1);
          anomalyIntervalId = setInterval(triggerAnomalyCheck, tickInterval);
           console.log(`Anomaly check interval started: every ${(tickInterval/1000).toFixed(1)}s`);
       }
       function stopAnomalyTimer() {
          if (anomalyIntervalId) clearInterval(anomalyIntervalId);
          anomalyIntervalId = null;
          console.log("Anomaly check interval stopped.");
       }


      // ========================================================================
      // --- Ascension V4 ---
      // ========================================================================
      function checkAscensionUnlock() {
           const levelMet = stats.level >= ASCENSION_UNLOCK_LEVEL;
           const itemsMet = totalItemCounts[ASCENSION_UNLOCK_RARITY] === 0 || // Handle if no items of this rarity exist
              items.filter(i => i.rarity === ASCENSION_UNLOCK_RARITY)
                   .every(itemDef => inventory[itemDef.name]?.count > 0);

           canAscend = levelMet && itemsMet;

          if (canAscend) {
              DOMElements.ascensionTabButton.classList.remove('hidden');
               DOMElements.ascendButton.disabled = false;
               DOMElements.ascendButton.textContent = `Ascend Now (${formatNumber(calculateEssenceGain())} ğŸŒŒ)`;
               DOMElements.essenceOnAscend.textContent = formatNumber(calculateEssenceGain());
           } else {
               // Keep button disabled, maybe update requirement text?
               DOMElements.ascendButton.disabled = true;
               DOMElements.ascendButton.textContent = `Ascend Now`;
               DOMElements.essenceOnAscend.textContent = `(${formatNumber(calculateEssenceGain())} ğŸŒŒ)`; // Still show potential gain
                // Hide tab if conditions NOT met (prevents accidental showing)
               // We don't hide it here usually, only reveal. Let user see the requirements.
           }
           // Also reveal essence display in header if any essence earned OR ascension possible
          if (stats.totalEssenceEarned > 0 || canAscend) {
              DOMElements.essenceDisplay.classList.remove('hidden');
           }

      }

      function calculateEssenceGain() {
           // Example formula: sqrt(levels) + num_mythics * 5 + log(total_rolls) ?
           // Keep it simple for now: floor(Level / 10) + floor(totalUniqueItems / 20) + floor(sets_completed / 2)
           const levelBonus = Math.floor(stats.level / 10);
          const uniqueBonus = Math.floor(Object.keys(inventory).length / 25); // Need more uniques
           const setsBonus = Math.floor(Object.keys(completedSets).length / 2);
          const mythicBonus = items.filter(i => i.rarity === 'Mythic' && inventory[i.name]?.count > 0).length * 2; // Bonus per unique Mythic owned
          const totalEssence = levelBonus + uniqueBonus + setsBonus + mythicBonus;
           return Math.max(1, totalEssence); // Guarantee at least 1 essence
      }

       function ascend() {
          if (!canAscend) {
               showToast("Ascension requirements not met!", "warning");
               return;
           }
          if (!confirm(`Are you sure you want to Ascend? \n\nThis will reset Level, XP, Shards, Items, Infusions, and Rolls, but grant ${formatNumber(calculateEssenceGain())} Essence for permanent upgrades. \n\nAchievements, Sets, and Essence ARE kept.`)) {
               return;
          }

          // Calculate gains BEFORE resetting
           const essenceGained = calculateEssenceGain();

          // Preserve data that persists
           const keptAchievements = { ...playerAchievements };
           const keptSets = { ...completedSets };
           const keptEssence = stats.essence + essenceGained;
           const keptTotalEssence = stats.totalEssenceEarned + essenceGained;
           const keptAscensions = stats.ascensions + 1;
           const keptCrafts = stats.itemsCrafted; // Keep craft count? Maybe reset? Keep for now.
           const keptAnomaliesTotal = stats.anomaliesEncountered; // Keep total encounters stat
           const keptUniqueAnomalies = { ...(stats.uniqueAnomalies || {}) };
           const keptNegSurvived = stats.negativeAnomaliesSurvived;
          const keptAscensionUpgrades = { ...(stats.ascensionUpgrades || {}) }; // Keep bought upgrades

          // Perform Reset
          stopAnomalyTimer(); // Stop anomaly timer during reset
          activeAnomalies = {}; // Clear active anomalies
          resetGameState(); // Resets most stats, inventory etc.

          // Restore persistent data
           playerAchievements = keptAchievements;
           completedSets = keptSets;
           stats.essence = keptEssence;
           stats.totalEssenceEarned = keptTotalEssence;
           stats.ascensions = keptAscensions;
           stats.itemsCrafted = keptCrafts;
           stats.anomaliesEncountered = keptAnomaliesTotal;
           stats.uniqueAnomalies = keptUniqueAnomalies;
           stats.negativeAnomaliesSurvived = keptNegSurvived;
           stats.ascensionUpgrades = keptAscensionUpgrades;


           console.log(`Ascended! Gained ${essenceGained} Essence. Total: ${stats.essence}`);
           showToast(`Ascended! Gained ${formatNumber(essenceGained)} ğŸŒŒ Essence!`, 'success', 5000);

           // Update UI completely
           loadData(); // Reload to apply base state + kept state + UI updates
           startAnomalyTimer(); // Restart anomaly timer after load
          // Check relevant achievements post-ascension
           checkAchievements('ascensions');
           checkAchievements('totalEssenceEarned');

          saveData(); // Save the new state after ascension
      }

      // ========================================================================
      // --- Achievement Logic V4 --- (Expanded conditions)
      // ========================================================================
       function checkAchievements(triggerType = null, triggerValue = null) {
           const uniqueItems = Object.values(inventory);
           const totalUnique = uniqueItems.length;
           const uniqueCountsByRarity = {};
           rarities.forEach(r => uniqueCountsByRarity[r] = 0);
           uniqueItems.forEach(invItem => { if (uniqueCountsByRarity[invItem.item.rarity] !== undefined) uniqueCountsByRarity[invItem.item.rarity]++; });
           const completedSetCount = Object.keys(completedSets).length;
           const uniqueAnomalyCount = Object.keys(stats.uniqueAnomalies || {}).length;

           let newAchievementUnlocked = false;

           achievements.forEach(ach => {
              if (!playerAchievements[ach.id]) {
                   let achieved = false; let currentProgress = 0;
                   const target = ach.target;

                   switch (ach.type) {
                       case 'rolls': achieved = stats.totalRolls >= target; currentProgress = stats.totalRolls; break;
                      case 'uniqueCount': achieved = (uniqueCountsByRarity[ach.rarity] || 0) >= target; currentProgress = uniqueCountsByRarity[ach.rarity] || 0; break;
                       case 'totalUnique': achieved = totalUnique >= target; currentProgress = totalUnique; break;
                       case 'totalShardsEarned': achieved = stats.totalShardsEarned >= target; currentProgress = stats.totalShardsEarned; break;
                       case 'maxInfusionLevel': achieved = stats.maxInfusionLevel >= target; currentProgress = stats.maxInfusionLevel; break;
                       case 'playerLevel': achieved = stats.level >= target; currentProgress = stats.level; break;
                       case 'setsCompleted': achieved = completedSetCount >= target; currentProgress = completedSetCount; break;
                       // V4 additions
                       case 'craftsMade': achieved = stats.itemsCrafted >= target; currentProgress = stats.itemsCrafted; break;
                       case 'craftRarity': achieved = (triggerType === 'craftRarity' && rarityConfig[triggerValue]?.index >= rarityConfig[ach.minRarity]?.index); currentProgress = playerAchievements[ach.id] ? 1 : 0; /* simpler progress */ break; // Only triggers once on specific craft
                       case 'craftSpecificType': achieved = (triggerType === 'craftSpecificType' && triggerValue === ach.outputType); currentProgress = playerAchievements[ach.id] ? 1 : 0; break; // Only triggers once
                      case 'anomaliesEncountered': achieved = stats.anomaliesEncountered >= target; currentProgress = stats.anomaliesEncountered; break;
                      case 'uniqueAnomaliesEncountered': achieved = uniqueAnomalyCount >= target; currentProgress = uniqueAnomalyCount; break;
                      case 'negativeAnomaliesSurvived': achieved = stats.negativeAnomaliesSurvived >= target; currentProgress = stats.negativeAnomaliesSurvived; break;
                      case 'totalEssenceEarned': achieved = stats.totalEssenceEarned >= target; currentProgress = stats.totalEssenceEarned; break;
                      case 'ascensions': achieved = stats.ascensions >= target; currentProgress = stats.ascensions; break;
                   }

                  if (achieved) { unlockAchievement(ach); newAchievementUnlocked = true; }
              }
          });

          if (newAchievementUnlocked) {
               displayAchievements(); // Update UI
               updateStatsDisplay(); // Update counts in stats tab
               saveData();
           }
       }

       function grantReward(reward, reason = "Reward") { /* ... (Handle new guaranteedRoll output type) ... */
           if (!reward) return; let messageParts = [];
           if (reward.type === 'shards' && reward.amount > 0) { addShards(reward.amount, reason); messageParts.push(`${formatNumber(reward.amount)} âœ¨`); }
           if (reward.type === 'xp' && reward.amount > 0) { addXP(reward.amount, reason); messageParts.push(`${formatNumber(reward.amount)} XP`); }
           if (reward.type === 'guaranteedRoll' && reward.amount > 0) { // Updated for new output type structure
              const rarity = reward.rarity || 'Uncommon'; stats.guaranteedRareRolls += reward.amount; updateGuaranteedRollButton(); messageParts.push(`${reward.amount}x ${rarity}+ Roll`);
          }
           // Check for complex reward object (e.g., from 'collectAll' achievement)
           const rewardKeys = Object.keys(reward).filter(k => !['type', 'rarity', 'amount'].includes(k) && reward[k] > 0); // Find actual reward keys like 'xp', 'shards'
           if (rewardKeys.length > 0 && messageParts.length === 0) { // Rebuild message if it was a complex object not parsed above
               if (reward.shards) { addShards(reward.shards, reason); messageParts.push(`${formatNumber(reward.shards)} âœ¨`); }
               if (reward.xp) { addXP(reward.xp, reason); messageParts.push(`${formatNumber(reward.xp)} XP`); }
               if (reward.guaranteedRareRoll) { stats.guaranteedRareRolls += reward.guaranteedRareRoll; updateGuaranteedRollButton(); messageParts.push(`${reward.guaranteedRareRoll}x Rare+ Roll`); }
           }
           if (messageParts.length > 0 && reason.startsWith("Achievement:")) { showToast(`Reward: ${messageParts.join(', ')}!`, 'success'); }
           else if (messageParts.length > 0) { console.log(`Granted Reward for ${reason}: ${messageParts.join(', ')}`); } // Log non-achievement rewards
       }
       function unlockAchievement(achievement) { /* ... (Grant base XP first) ... */ if (!playerAchievements[achievement.id]) { console.log(`Ach. Unlocked: ${achievement.name}`); playerAchievements[achievement.id] = true; addXP(50 + (Object.keys(playerAchievements).length * 2), 'achievement'); /* XP scales slightly */ grantReward(achievement.reward, `Achievement: ${achievement.name}`); showToast(`ğŸ† Ach: ${achievement.name}!`, 'success'); } }


      // ========================================================================
      // --- UI Updates V4 ---
      // ========================================================================
      function updatePlayerStatsUI() { /* ... (Display Essence) ... */
           DOMElements.playerLevel.textContent = formatNumber(stats.level); DOMElements.playerShards.textContent = formatNumber(stats.shards); DOMElements.playerXP.textContent = formatNumber(stats.xp);
           const xpNeeded = getXPForNextLevel(stats.level); DOMElements.xpToNextLevel.textContent = formatNumber(xpNeeded);
           const progress = xpNeeded > 0 ? Math.min(100, Math.floor((stats.xp / xpNeeded) * 100)) : 100; DOMElements.playerXPBar.style.width = `${progress}%`; DOMElements.playerXPBar.parentElement.setAttribute('data-tooltip', `${progress}%`);
          DOMElements.playerEssence.textContent = formatNumber(stats.essence); // Update Essence display
          checkAscensionUnlock(); // Recalculate potential essence gain & button state
       }
       function updateGuaranteedRollButton() { /* ... (Handle isRolling) ... */ if (stats.guaranteedRareRolls > 0) { DOMElements.guaranteedRollButton.classList.remove('hidden'); DOMElements.guaranteedRollButton.textContent = `Roll Rare+ (${stats.guaranteedRareRolls} Left)`; DOMElements.guaranteedRollButton.disabled = isRolling; } else { DOMElements.guaranteedRollButton.classList.add('hidden'); DOMElements.guaranteedRollButton.disabled = true; } }
      function updateRollCostDisplay() { /* ... (Show cost based on anomalies) ... */
           let baseCost = 0; // Assume base cost is 0 shards normally
          let costDisplay = "";
          for (const id in activeAnomalies) { const anomalyEffect = activeAnomalies[id].anomaly.effect; if (anomalyEffect && anomalyEffect.type === 'rollCostFlatIncrease') { baseCost += anomalyEffect.amount; } }
          if (baseCost > 0) { costDisplay = `(${formatNumber(baseCost)} âœ¨ Cost)`; DOMElements.rollButton.classList.add("text-red-300"); } // Indicate cost
          else { DOMElements.rollButton.classList.remove("text-red-300"); }
           DOMElements.rollCostDisplay.textContent = costDisplay;
       }


      // Enhanced result display with celebration/shake
      function updateResultDisplay(item) {
          const config = rarityConfig[item.rarity]; if (!config) { console.error("Invalid rarity config:", item); return;}
          const rarityColorClass = config.colorClass; const rarityBgClass = config.bgClass;
          const resultDiv = DOMElements.resultDisplay; const wrapper = DOMElements.resultDisplayWrapper;

          // Clear previous animations carefully
          resultDiv.className = `p-5 border rounded-lg shadow-md w-full text-center min-h-[180px] flex flex-col justify-center items-center transition-all duration-300 border-gray-300`; // Reset base classes
          wrapper.classList.remove('animate-shake'); // Remove shake if present
          resultDiv.classList.add(rarityBgClass);
          // resultDiv.classList.add(`border-${rarityColorClass.replace('rarity-','').toLowerCase()}-400`); // Dynamic border might not work without JIT / safelisting

           resultDiv.innerHTML = `
               <span class="text-5xl mb-3 transition-transform duration-300 hover:scale-110">${item.icon}</span>
               <p class="text-xl font-semibold ${rarityColorClass}">${item.name}</p>
               <p class="text-sm font-medium ${rarityColorClass} border px-2 py-0.5 rounded-full ${rarityColorClass} inline-block mt-1">${item.rarity}</p>
               <p class="text-xs text-gray-600 italic mt-2 px-3">${item.description || '...'}</p>
          `;

          // Determine celebration level based on rarity index
          let celebrationClass = '';
           if (config.index >= rarityConfig['Mythic'].index) celebrationClass = 'animate-celebrate-mythic';
           else if (config.index >= rarityConfig['Legendary'].index) celebrationClass = 'animate-celebrate-legendary';
           else if (config.index >= rarityConfig['Epic'].index) celebrationClass = 'animate-celebrate-epic';
           else if (config.index >= rarityConfig['Rare'].index) celebrationClass = 'animate-celebrate-rare';
          else celebrationClass = 'animate-pulse-quick'; // Just pulse for Common/Uncommon

           resultDiv.classList.add(celebrationClass);

          // Add subtle shake effect to the wrapper for rare+
           if (config.index >= rarityConfig['Rare'].index) {
              wrapper.classList.add('animate-shake');
               // Remove shake after animation ends
               setTimeout(() => { wrapper.classList.remove('animate-shake'); }, 600); // Matches shake animation duration
           }

          // Remove *persistent* glow animations after a delay (celebration pop is finite)
           if (celebrationClass.includes('animate-celebrate')) {
               setTimeout(() => {
                   resultDiv.classList.remove('animate-glow-rare', 'animate-glow-epic', 'animate-glow-legendary', 'animate-glow-mythic');
               }, 1500); // Keep glow visible for 1.5s
          }
      }

      // Update Inventory Display V4: Filter by effect, show effect icon
      function updateInventoryDisplay() {
          const list = DOMElements.inventoryList; const emptyMsg = DOMElements.emptyInventoryMsg; list.innerHTML = '';
          const inventoryItems = Object.values(inventory); const sortFn = getSortFunction();

          // --- Filtering V4 ---
          const filteredItems = inventoryItems.filter(invItem => {
              const itemDef = items.find(i => i.name === invItem.item.name); // Get full def
              if (currentInventoryFilter === 'all') return true;
              if (currentInventoryFilter === 'has_effect') return !!itemDef?.effect; // Check if item def has effect property
              return invItem.item.rarity === currentInventoryFilter; // Filter by rarity
          });
          // --- End Filtering ---

          const sortedInventory = filteredItems.sort(sortFn);

          let totalItemsCount = inventoryItems.reduce((sum, i) => sum + i.count, 0); // Total including filtered out

          if (sortedInventory.length === 0) {
              emptyMsg.style.display = 'block';
              if (currentInventoryFilter !== 'all') {
                  let filterText = currentInventoryFilter;
                   if (filterText === 'has_effect') filterText = 'items with effects';
                  emptyMsg.textContent = `No ${filterText} found in your collection.`;
              } else emptyMsg.textContent = `Your collection is empty. Go roll some items!`;
          } else {
              emptyMsg.style.display = 'none';
              sortedInventory.forEach(invItem => {
                   const item = invItem.item; const count = invItem.count; const level = invItem.level;
                   const itemDef = items.find(i => i.name === item.name); // Full definition for effect check
                  const config = rarityConfig[item.rarity]; const sellValue = getSellValue(invItem);
                   const effect = itemDef?.effect;

                  const listItem = document.createElement('div');
                  listItem.className = `inventory-item flex justify-between items-center p-2 border-b border-gray-200 last:border-b-0 ${config?.bgClass || 'bg-gray-100'} rounded-md hover:shadow-md transition-shadow duration-200`;

                  listItem.innerHTML = `
                       <div class="flex items-center space-x-3 flex-grow mr-2">
                            <span class="text-2xl">${item.icon}</span>
                            <div class="flex-grow">
                                <span class="font-medium text-gray-800 text-sm sm:text-base">${item.name}</span>
                                ${effect ? `<i class="fas fa-star text-yellow-500 effect-icon" data-tooltip="${effect.desc || 'Has a special effect!'}"></i>` : ''}
                                 <span class="text-xs font-semibold ${config?.colorClass || 'text-gray-500'} border px-1.5 py-0.5 rounded-full ${config?.colorClass || 'border-gray-300'}">${item.rarity}</span>
                                ${level > 1 ? `<span class="ml-2 text-xs font-semibold text-indigo-600 bg-indigo-100 px-1.5 py-0.5 rounded-full">Lvl ${level}</span>` : ''}
                                 <p class="text-xs text-gray-500 italic mt-0.5 hidden sm:block">${item.description || ''}</p>
                           </div>
                       </div>
                       <div class="flex items-center space-x-2 flex-shrink-0">
                           <div class="text-right mr-2">
                                <span class="text-sm font-semibold text-gray-700 bg-gray-200 px-2 py-0.5 rounded-md">x${formatNumber(count)}</span>
                                <div class="text-xs text-amber-700" data-tooltip="Sell Value">${formatNumber(sellValue)} âœ¨</div>
                           </div>
                           <div class="inventory-item-actions flex flex-col sm:flex-row gap-1 sm:gap-2 items-center">
                                <button class="btn btn-xs btn-warning sell-button" data-itemname="${item.name}" data-tooltip="Sell 1">Sell</button>
                                ${count > 1 ? `<button class="btn btn-xs btn-danger sell-all-button" data-itemname="${item.name}" data-tooltip="Sell Duplicates (${count - 1})">Sell Dupes</button>` : ''}
                          </div>
                      </div>
                   `;
                  list.appendChild(listItem);
               });
           }
          // Update counts display - Use total unique from unfiltered list
          const uniqueCount = Object.keys(inventory).length;
           DOMElements.inventoryCountDisplay.textContent = `Unique: ${formatNumber(uniqueCount)}/${formatNumber(items.length)} | Total Items: ${formatNumber(totalItemsCount)}`;
          // Event listeners added as before
           list.querySelectorAll('.sell-button').forEach(b => b.addEventListener('click', (e) => sellItem(e.target.closest('button').dataset.itemname, 1)));
           list.querySelectorAll('.sell-all-button').forEach(b => b.addEventListener('click', (e) => sellAllDuplicates(e.target.closest('button').dataset.itemname)));
      }

      // Update Infusion UI V4: Use getInfusionCost (handles anomalies/items)
       function updateInfusionUI(itemName) { /* ... (UI structure same, but fetch cost using getInfusionCost) ... */
          const detailsDiv = DOMElements.infusionDetails; const button = DOMElements.infuseItemButton;
          if (!itemName || !inventory[itemName]) { selectedItemForInfusion = null; detailsDiv.innerHTML = `<p class="text-gray-500 italic text-lg">Select an item</p>`; button.classList.add('hidden'); button.disabled = true; return; }
          const itemData = inventory[itemName]; const item = itemData.item; const level = itemData.level; const config = rarityConfig[item.rarity];
          const cost = getInfusionCost(itemData); // <<< USES UPDATED FUNCTION
          const sellValue = getSellValue(itemData); const nextLevelSellValue = getSellValue({ ...itemData, level: level + 1 });

           detailsDiv.innerHTML = `
               <div class="flex flex-col items-center">
                   <span class="text-6xl mb-4">${item.icon}</span> <p class="text-2xl font-semibold ${config.colorClass}">${item.name}</p>
                   <p class="text-lg font-medium ${config.colorClass} border px-3 py-0.5 rounded-full ${config.colorClass} inline-block mt-1">${item.rarity}</p>
                   <p class="text-sm text-gray-600 italic mt-2 max-w-sm">${item.description || ''}</p>
                   <div class="mt-6 border-t pt-4 w-full max-w-md flex justify-around text-center">
                      <div> <div class="text-gray-500 text-sm font-medium">Current Lvl</div> <div class="text-2xl font-bold text-indigo-600">${level}</div> </div>
                      <div> <div class="text-gray-500 text-sm font-medium">Sell Value</div> <div class="text-xl font-bold text-amber-700">${formatNumber(sellValue)} âœ¨</div> </div>
                  </div>
                  <div class="mt-4 w-full max-w-md text-center bg-white p-4 rounded-lg shadow">
                      <p class="text-gray-600 text-sm">Infuse to <span class="font-bold text-indigo-600">Level ${level + 1}</span>?</p>
                      <p class="text-sm mt-1">Cost: <span class="font-bold text-lg ${stats.shards >= cost ? 'text-green-600' : 'text-red-600'}">${formatNumber(cost)} âœ¨</span></p>
                      <p class="text-xs text-gray-500 mt-1">(Sell Value will be ${formatNumber(nextLevelSellValue)} âœ¨)</p>
                   </div>
              </div>
          `;
          button.classList.remove('hidden'); DOMElements.infuseButtonCost.textContent = `(${formatNumber(cost)})`; button.disabled = !(stats.shards >= cost); button.dataset.itemname = itemName;
      }
      function updateInfusionSelectionList() { /* Uses getInfusionCost to display cost */
           const list = DOMElements.infuseSelectionList; const emptyMsg = DOMElements.emptyInfuseList; list.innerHTML = '';
           const inventoryItems = Object.values(inventory); if (inventoryItems.length === 0) { emptyMsg.style.display = 'block'; return; } emptyMsg.style.display = 'none';
           const sortFn = getSortFunction(); inventoryItems.sort(sortFn);
           inventoryItems.forEach(invItem => { const item = invItem.item; const level = invItem.level; const config = rarityConfig[item.rarity]; const cost = getInfusionCost(invItem); const affordable = stats.shards >= cost; const entry = document.createElement('div'); entry.className = `infuse-item-entry flex justify-between items-center p-2 border rounded cursor-pointer hover:bg-gray-100 ${config.bgClass} ${selectedItemForInfusion === item.name ? 'infuse-selected' : ''}`; entry.dataset.itemname = item.name; entry.innerHTML = `<div class="flex items-center space-x-2"><span class="text-xl">${item.icon}</span><div><span class="font-medium text-sm ${config.colorClass}">${item.name}</span><span class="block text-xs ${config.colorClass}">${item.rarity} | Lvl ${level}</span></div></div><div class="text-right text-xs"><span class="font-medium ${affordable ? 'text-green-600' : 'text-red-600'}">${formatNumber(cost)} âœ¨</span><span class="block text-gray-500">Next Lvl</span></div>`; entry.addEventListener('click', () => selectItemForInfusion(item.name)); list.appendChild(entry); });
       }
      function selectItemForInfusion(itemName) { /* ... (same logic) ... */ if (selectedItemForInfusion === itemName) selectedItemForInfusion = null; else selectedItemForInfusion = itemName; DOMElements.infuseSelectionList.querySelectorAll('.infuse-item-entry').forEach(el => el.classList.toggle('infuse-selected', el.dataset.itemname === selectedItemForInfusion)); updateInfusionUI(selectedItemForInfusion); }
      function displaySets() { /* ... (Needs update to apply item setBonusMultiplier potentially) ... */
          const list = DOMElements.setList; const loadingMsg = DOMElements.loadingSetsMsg; list.innerHTML = ''; loadingMsg.style.display = 'none';
          if (collectionSets.length === 0) { list.innerHTML = '<p class="italic col-span-full text-center">No sets defined.</p>'; return; }
          const setBonusMultiplier = calculateCumulativeItemEffects()?.setBonusMultiplier || 1; // Get potential multiplier
          collectionSets.forEach(set => { const isComplete = completedSets[set.id]; const ownedItemsInSet = set.items.filter(name => inventory[name]?.count > 0); const progressPercent = set.items.length > 0 ? Math.floor((ownedItemsInSet.length / set.items.length) * 100) : 0; const setElement = document.createElement('div'); setElement.className = `p-4 rounded-lg border ${isComplete ? 'set-complete bg-amber-50 border-amber-200 shadow-md' : 'set-incomplete bg-gray-50 border-gray-200'} transition-all duration-300`; let itemIconsHTML = set.items.map(name => { const owned = inventory[name]?.count > 0; const itemDef = items.find(i => i.name === name); const icon = itemDef?.icon || '?'; return `<span class="${owned ? '' : 'opacity-30 filter grayscale'}" data-tooltip="${name} ${owned ? '(Owned)' : '(Missing)'}">${icon}</span>`; }).join(' '); let effectiveBonusDesc = set.rewardDesc; if (isComplete && setBonusMultiplier !== 1) effectiveBonusDesc += ` <span class="text-xs font-bold text-purple-600">(x${setBonusMultiplier.toFixed(2)})</span>`; /* Show multiplier */ setElement.innerHTML = `<div class="flex items-center space-x-3 mb-3"><i class="${set.icon || 'fa-solid fa-question'} fa-lg ${isComplete ? 'text-amber-600' : 'text-gray-400'}"></i><div><h4 class="font-semibold ${isComplete ? 'text-amber-800' : 'text-gray-700'}">${set.name}</h4><p class="text-sm ${isComplete ? 'text-amber-700 font-medium' : 'text-gray-500'}">Bonus: ${effectiveBonusDesc}</p></div></div><div class="mb-2 flex items-center space-x-1 text-xl">${itemIconsHTML}</div><div class="progress-bar-bg !h-1.5"><div class="progress-bar-fill ${isComplete ? '!bg-amber-400' : '!bg-indigo-400'} !h-1.5" style="width: ${progressPercent}%;"></div></div><p class="text-xs text-right mt-1 ${isComplete ? 'text-amber-600' : 'text-gray-500'}">${ownedItemsInSet.length}/${set.items.length} (${progressPercent}%)</p>`; list.appendChild(setElement); });
      }
      function displayAchievements() { /* Uses updated checkAchievements progress values */
          const list = DOMElements.achievementList; const loadingMsg = DOMElements.loadingAchievementsMsg; list.innerHTML = ''; loadingMsg.style.display = 'none';
          const uniqueItems = Object.values(inventory); const totalUnique = uniqueItems.length; const uniqueCountsByRarity = {}; rarities.forEach(r => uniqueCountsByRarity[r] = 0); uniqueItems.forEach(inv => { if (uniqueCountsByRarity[inv.item.rarity]!==undefined) uniqueCountsByRarity[inv.item.rarity]++; }); const completedSetCount = Object.keys(completedSets).length; const uniqueAnomalyCount = Object.keys(stats.uniqueAnomalies || {}).length;
          achievements.forEach(ach => { const isUnlocked = playerAchievements[ach.id]; const achElement = document.createElement('div'); achElement.className = `p-4 rounded-lg border ${isUnlocked ? 'achievement-unlocked bg-green-50 border-green-200 shadow-md' : 'achievement-locked bg-gray-50 border-gray-200'} transition-all duration-300 flex flex-col justify-between`; let progressText = ''; let progressPercent = 0; if (!isUnlocked) { let currentValue = 0; let targetValue = ach.target; switch (ach.type) { /* ... (All cases from checkAchievements to get currentValue) ... */ case 'rolls': currentValue = stats.totalRolls; break; case 'uniqueCount': currentValue = uniqueCountsByRarity[ach.rarity]||0; break; case 'totalUnique': currentValue = totalUnique; break; case 'totalShardsEarned': currentValue = stats.totalShardsEarned; break; case 'maxInfusionLevel': currentValue = stats.maxInfusionLevel; break; case 'playerLevel': currentValue = stats.level; break; case 'setsCompleted': currentValue = completedSetCount; break; case 'craftsMade': currentValue = stats.itemsCrafted; break; case 'craftRarity': case 'craftSpecificType': currentValue=0; targetValue=1; break; /* Simplified progress for trigger only */ case 'anomaliesEncountered': currentValue = stats.anomaliesEncountered; break; case 'uniqueAnomaliesEncountered': currentValue = uniqueAnomalyCount; break; case 'negativeAnomaliesSurvived': currentValue = stats.negativeAnomaliesSurvived; break; case 'totalEssenceEarned': currentValue = stats.totalEssenceEarned; break; case 'ascensions': currentValue = stats.ascensions; break; } currentValue = Math.min(currentValue, targetValue); progressText = `(${formatNumber(currentValue)}/${formatNumber(targetValue)})`; if (targetValue > 0) progressPercent = Math.floor((currentValue / targetValue) * 100); } else progressPercent = 100; let rewardText = 'None'; /* ... (Reward formatting from V3) ... */ if(ach.reward){let parts=[]; const process=(r,p)=>{if(r.type==='shards')p.push(`${formatNumber(r.amount)}âœ¨`);if(r.type==='xp')p.push(`${formatNumber(r.amount)} XP`);if(r.type==='guaranteedRoll')p.push(`${r.amount||1}x ${r.rarity||'Rare'}+ Roll`);}; process(ach.reward,parts);if(Object.keys(ach.reward).filter(k=>!['type','rarity','amount'].includes(k)&&ach.reward[k]>0).length>0&&parts.length===0){if(ach.reward.shards)parts.push(`${formatNumber(ach.reward.shards)}âœ¨`);if(ach.reward.xp)parts.push(`${formatNumber(ach.reward.xp)} XP`);if(ach.reward.guaranteedRareRoll)parts.push(`${ach.reward.guaranteedRareRoll}x Rare+ Roll`);}if(parts.length>0)rewardText=parts.join(', ');} achElement.innerHTML = `<div><div class="flex items-center space-x-3 mb-2"><i class="${ach.icon||'fa-solid fa-question'} fa-lg ${isUnlocked ? 'text-green-600' : 'text-gray-400'}"></i><div><h4 class="font-semibold ${isUnlocked?'text-green-800':'text-gray-700'}">${ach.name}</h4><p class="text-sm ${isUnlocked?'text-green-700':'text-gray-500'}">${ach.description}</p></div></div>${isUnlocked ? `<p class="text-xs font-bold text-green-600 mt-1"><i class="fa-solid fa-check"></i> Done! Reward: ${rewardText}</p>` : `<p class="text-xs font-medium text-indigo-600 mt-1">Reward: ${rewardText}</p>`}</div>${!isUnlocked?`<div class="mt-2"><div class="progress-bar-bg !h-1.5"><div class="progress-bar-fill !bg-indigo-400 !h-1.5" style="width:${progressPercent}%;"></div></div><p class="text-xs text-right text-gray-500 mt-0.5">${progressText}</p></div>`:''}`; list.appendChild(achElement); });
      }
      function updateStatsDisplay() { /* Added V4 Stats */
           const unlockedAchCount = Object.keys(playerAchievements).length; const completedSetCount = Object.keys(completedSets).length;
          DOMElements.totalRollsStat.textContent = formatNumber(stats.totalRolls); DOMElements.commonStat.textContent = formatNumber(stats.commonCount); DOMElements.uncommonStat.textContent = formatNumber(stats.uncommonCount); DOMElements.rareStat.textContent = formatNumber(stats.rareCount); DOMElements.epicStat.textContent = formatNumber(stats.epicCount); DOMElements.legendaryStat.textContent = formatNumber(stats.legendaryCount); DOMElements.mythicStat.textContent = formatNumber(stats.mythicCount);
           DOMElements.completedSetsStat.textContent = `${formatNumber(completedSetCount)}/${collectionSets.length}`; DOMElements.achievementsUnlockedStat.textContent = `${formatNumber(unlockedAchCount)}/${achievements.length}`;
           DOMElements.maxInfusionStat.textContent = formatNumber(stats.maxInfusionLevel); DOMElements.totalShardsEarnedStat.textContent = formatNumber(stats.totalShardsEarned);
           // V4 additions
           DOMElements.itemsCraftedStat.textContent = formatNumber(stats.itemsCrafted);
           DOMElements.anomaliesEncounteredStat.textContent = formatNumber(stats.anomaliesEncountered);
           DOMElements.totalEssenceEarnedStat.textContent = formatNumber(stats.totalEssenceEarned);
           if (document.getElementById('tabContent-achievements').classList.contains('active')) { displayAchievements(); }
      }


      // --- Main Game Loop (Roll Handling) V4 ---
      function handleRoll(minRarity = 'Common', isFreeReroll = false) {
          if (isRolling) return;

          // Apply Roll Cost (Anomalies only for now)
          let rollCost = 0;
           for (const id in activeAnomalies) { const anomalyEffect = activeAnomalies[id].anomaly.effect; if (anomalyEffect?.type === 'rollCostFlatIncrease') rollCost += anomalyEffect.amount; }

          // If not a free reroll and costs shards, attempt to deduct
           if (!isFreeReroll && rollCost > 0) {
               if (!addShards(-rollCost, "roll cost anomaly")) {
                   showToast(`Cannot roll! Cost is ${rollCost} âœ¨ due to anomaly.`, "error");
                  return; // Not enough shards, abort roll
               }
           }


           isRolling = true;
          DOMElements.rollButton.disabled = true; DOMElements.guaranteedRollButton.disabled = true;

          // Roll Animation Delay
          setTimeout(() => {
              let newItem = getRandomItem(minRarity);
              let finalItem = newItem; // Assume this is the final result initially

              // --- Reroll Logic ---
               if (newItem) {
                  const itemEffects = calculateCumulativeItemEffects();
                  if (!isFreeReroll && itemEffects.rerollBelowEpicChance > 0 && rarityConfig[newItem.rarity]?.index < rarityConfig['Epic'].index) {
                      if (Math.random() < itemEffects.rerollBelowEpicChance) {
                          console.log(`Rerolling ${newItem.name} (${newItem.rarity}) due to item effect!`);
                           showToast(`Bonus reroll triggered!`, 'success', 1500);
                          // Perform the second roll *immediately* within the same blocked 'isRolling' period
                           const rerolledItem = getRandomItem(minRarity); // Same minimum rarity for reroll
                           if (rerolledItem) {
                              console.log(`Rerolled into: ${rerolledItem.name} (${rerolledItem.rarity})`);
                               finalItem = rerolledItem; // Use the rerolled item as the final result
                           } else {
                               console.warn("Reroll attempt failed to get an item, keeping original.");
                           }
                       }
                   }
               }
              // --- End Reroll Logic ---

              if (finalItem) {
                   // --- Process Final Item ---
                  updateResultDisplay(finalItem);
                  addToInventory(finalItem);
                   stats.totalRolls++;

                   // Increment specific rarity count ONLY for the FINAL item obtained
                  const rarityKey = `${finalItem.rarity.toLowerCase()}Count`;
                  if (stats.hasOwnProperty(rarityKey)) stats[rarityKey]++;

                  // Grant Base XP for the roll (based on final item rarity) & flat item bonus XP
                  addXP(rarityConfig[finalItem.rarity]?.xpOnRoll || 1, 'roll');
                  // Add flat shard bonus per roll from items FIRST
                   let flatShardBonus = calculateCumulativeItemEffects().shardPerRollFlat || 0;
                  // Add specific bonus for common rolls if applicable
                   if (finalItem.rarity === 'Common' && (calculateCumulativeItemEffects().shardBonusCommonRoll||0) > 0) {
                      flatShardBonus += calculateCumulativeItemEffects().shardBonusCommonRoll;
                  }
                   if(flatShardBonus > 0) addShards(flatShardBonus, "item effect flat bonus");


                   // Grant additional Shards based on final item ROLLED (from Sets/Anomalies - use Base value for addShards)
                  let rollShardBonusAmount = 0;
                  Object.keys(completedSets).forEach(setId => { const set = collectionSets.find(s => s.id === setId); if (set?.bonus?.type === 'shardBonusOnRoll' && set.bonus.rarities.includes(finalItem.rarity)) rollShardBonusAmount += (set.bonus.amount || 0); });
                  if(rollShardBonusAmount > 0) addShards(rollShardBonusAmount, `set bonus for ${finalItem.rarity} roll`); // addShards applies multiplier

                   // Grant % Shard Bonus (calculated inside addShards)
                   let baseShardGainForPercent = 1; // Placeholder: What should the % bonus apply to? Maybe the sell value? Or just 1? Let's apply to a base of 1 shard per roll for simplicity now.
                  addShards(baseShardGainForPercent, `item effect % bonus`); // This adds 0 base, but the multiplier inside addShards will add the percentage


                   // --- UI & State Updates ---
                   updateInventoryDisplay();
                   updateStatsDisplay();
                   updatePlayerStatsUI();
                   checkAchievements(); // Check AFTER all state changes from the roll
                   if (document.getElementById('tabContent-crafting').classList.contains('active')) updateCraftingUI(); // Update recipe availability
                   if (document.getElementById('tabContent-infuse').classList.contains('active')) { updateInfusionSelectionList(); if (selectedItemForInfusion) updateInfusionUI(selectedItemForInfusion); }
                   if (document.getElementById('tabContent-sets').classList.contains('active')) displaySets();
                   if (document.getElementById('tabContent-ascension').classList.contains('active')) checkAscensionUnlock(); // Update potential Essence gain display


                   saveData();
               } else {
                   console.error("Failed to get a final random item.");
                   DOMElements.resultDisplay.innerHTML = `<p class="text-red-500">Error: Could not get item.</p>`;
                   showToast("Error during roll.", 'error');
               }

               isRolling = false;
               DOMElements.rollButton.disabled = false;
               updateGuaranteedRollButton();
          }, 150); // Slightly shorter delay
      }


      // ========================================================================
      // --- Tab Switching Logic V4 --- (Handles new tabs)
      // ========================================================================
       function switchTab(event) {
           const targetTab = event.target.dataset.tab; if (!targetTab) return;
           DOMElements.tabs.forEach(button => button.classList.toggle('active', button.dataset.tab === targetTab));
           DOMElements.tabContents.forEach(content => {
              const isActive = content.id === `tabContent-${targetTab}`;
               content.classList.toggle('active', isActive);
               if (isActive) { // Refresh content on activation
                   if (targetTab === 'collection') updateInventoryDisplay();
                   if (targetTab === 'crafting') updateCraftingUI(); // Refresh recipes
                   if (targetTab === 'infuse') { updateInfusionSelectionList(); updateInfusionUI(selectedItemForInfusion); }
                   if (targetTab === 'sets') displaySets();
                   if (targetTab === 'achievements') displayAchievements();
                   if (targetTab === 'stats') updateStatsDisplay();
                   if (targetTab === 'ascension') checkAscensionUnlock(); // Update info when tab opened
               }
           });
       }


      // ========================================================================
      // --- Persistence V4 --- (Adds Anomaly state, Ascension data)
      // ========================================================================
      const SAVE_KEYS = { /* V4 Uses new prefix set earlier */
           inventory: `${SAVE_KEY_PREFIX}inventory`, stats: `${SAVE_KEY_PREFIX}stats`,
           achievements: `${SAVE_KEY_PREFIX}achievements`, sets: `${SAVE_KEY_PREFIX}sets`,
           settings: `${SAVE_KEY_PREFIX}settings`, activeAnomalies: `${SAVE_KEY_PREFIX}anomalies`, // Save active anomalies + expiry
       };
      function saveData() {
           try {
               localStorage.setItem(SAVE_KEYS.inventory, JSON.stringify(inventory));
               localStorage.setItem(SAVE_KEYS.stats, JSON.stringify(stats));
               localStorage.setItem(SAVE_KEYS.achievements, JSON.stringify(playerAchievements));
               localStorage.setItem(SAVE_KEYS.sets, JSON.stringify(completedSets));
               localStorage.setItem(SAVE_KEYS.settings, JSON.stringify({ sort: currentInventorySort, filter: currentInventoryFilter }));
               // Save active anomalies with remaining duration calculation potentially (or just expiry time)
               localStorage.setItem(SAVE_KEYS.activeAnomalies, JSON.stringify(activeAnomalies));
           } catch (e) { console.error("Error saving data:", e); showToast("Error saving game data.", "error", 5000); }
      }

      function resetGameState() { // Reset V4 Stats
           inventory = {};
           stats = {
               totalRolls: 0, commonCount: 0, uncommonCount: 0, rareCount: 0, epicCount: 0, legendaryCount: 0, mythicCount: 0,
               guaranteedRareRolls: 0, shards: 0, xp: 0, level: 1,
               totalShardsEarned: 0, maxInfusionLevel: 0,
               itemsCrafted: 0, // New V4 stat
               anomaliesEncountered: 0, // New V4 stat
               uniqueAnomalies: {}, // Store unique IDs encountered
               negativeAnomaliesSurvived: 0, // New V4 stat
               essence: 0, // Prestige currency
               totalEssenceEarned: 0, // For achievements tracking total gain
               ascensions: 0, // Number of times ascended
              ascensionUpgrades: {} // Store purchased prestige upgrades
           };
           playerAchievements = {}; completedSets = {}; selectedItemForInfusion = null;
           currentInventorySort = 'rarity_desc'; currentInventoryFilter = 'all';
           DOMElements.inventorySort.value = currentInventorySort; DOMElements.inventoryFilter.value = currentInventoryFilter;
           canAscend = false;
           activeAnomalies = {}; // Clear active anomalies
           stopAnomalyTimer(); // Stop timer on reset
           inventoryChangedSinceLastEffectCalc = true; // Force effect recalc
          console.log("Game state reset.");
       }

      function loadData() { // Load V4 Data
           resetGameState(); // Start clean
           try {
               const savedInventory = localStorage.getItem(SAVE_KEYS.inventory);
               const savedStats = localStorage.getItem(SAVE_KEYS.stats);
               const savedAchievements = localStorage.getItem(SAVE_KEYS.achievements);
               const savedSets = localStorage.getItem(SAVE_KEYS.sets);
               const savedSettings = localStorage.getItem(SAVE_KEYS.settings);
               const savedAnomalies = localStorage.getItem(SAVE_KEYS.activeAnomalies);

               if (savedInventory) { let loadedInv = JSON.parse(savedInventory); Object.keys(loadedInv).forEach(name=>{ if(!loadedInv[name].level)loadedInv[name].level=1; /* migration */ }); inventory = loadedInv; }
               if (savedStats) { let loadedStats = JSON.parse(savedStats); stats = { ...stats, ...loadedStats }; /* Merge defaults and loaded */}
               if (savedAchievements) playerAchievements = JSON.parse(savedAchievements);
               if (savedSets) completedSets = JSON.parse(savedSets);
               if (savedSettings) { const settings = JSON.parse(savedSettings); currentInventorySort = settings.sort || 'rarity_desc'; currentInventoryFilter = settings.filter || 'all'; DOMElements.inventorySort.value = currentInventorySort; DOMElements.inventoryFilter.value = currentInventoryFilter; }
               if (savedAnomalies) {
                   const now = Date.now();
                   const loadedAnomalies = JSON.parse(savedAnomalies);
                   for (const id in loadedAnomalies) {
                       if (loadedAnomalies[id].expires > now) { // Only load non-expired
                           const anomalyDef = anomalies.find(a => a.id === id);
                           if (anomalyDef) {
                               activeAnomalies[id] = { anomaly: anomalyDef, expires: loadedAnomalies[id].expires };
                               // Reschedule timeout for remaining duration
                                setTimeout(() => endAnomaly(id), loadedAnomalies[id].expires - now);
                           } else { console.warn(`Loaded active anomaly "${id}" but definition not found.`); }
                       } else { console.log(`Anomaly ${id} already expired, not loading.`); }
                   }
                   displayActiveAnomalies(); // Show loaded anomalies
               }

              inventoryChangedSinceLastEffectCalc = true; // Need to recalc effects after load

           } catch (e) { console.error("Error loading data:", e); showToast("Error loading save data. Starting fresh.", "error"); resetGameState(); }

          // --- Initial UI Updates after load ---
          updatePlayerStatsUI(); // Includes essence & ascension button update via checkAscensionUnlock
          updateInventoryDisplay(); updateStatsDisplay(); updateGuaranteedRollButton();
          displayAchievements(); displaySets();
          updateCumulativeEffectsUI(calculateCumulativeItemEffects()); // Calculate and display initial effects
          updateRollCostDisplay(); // Update roll cost display

          if (document.getElementById('tabContent-crafting').classList.contains('active')) updateCraftingUI(); // Needs to be called here after load
           if (document.getElementById('tabContent-infuse').classList.contains('active')) { updateInfusionSelectionList(); updateInfusionUI(selectedItemForInfusion); }

          startAnomalyTimer(); // Start checking for new anomalies
       }

      // --- Initialize Game V4 ---
      function initializeGame() {
          console.log(`RNG Collector V4 Init... Items: ${items.length}, Recipes: ${craftingRecipes.length}, Anomalies: ${anomalies.length}`);
          populateFilterDropdown(); loadData();

          // Event Listeners
          DOMElements.tabs.forEach(b => b.addEventListener('click', switchTab));
          DOMElements.rollButton.addEventListener('click', () => handleRoll());
          DOMElements.guaranteedRollButton.addEventListener('click', () => { if (stats.guaranteedRareRolls > 0 && !isRolling) { stats.guaranteedRareRolls--; handleRoll('Rare'); updateGuaranteedRollButton(); /* Save inside handleRoll */ } });
          DOMElements.infuseItemButton.addEventListener('click', (e) => { if (e.target.dataset.itemname) infuseItem(e.target.dataset.itemname); });
          DOMElements.inventorySort.addEventListener('change', (e) => { currentInventorySort = e.target.value; updateInventoryDisplay(); saveData(); });
          DOMElements.inventoryFilter.addEventListener('change', (e) => { currentInventoryFilter = e.target.value; updateInventoryDisplay(); saveData(); });
          DOMElements.resetDataButton.addEventListener('click', () => { if (confirm("Reset ALL game data? Irreversible!")) { Object.values(SAVE_KEYS).forEach(key => localStorage.removeItem(key)); resetGameState(); loadData(); showToast("Game data reset.", "warning"); } });
          DOMElements.ascendButton.addEventListener('click', ascend); // Add listener for ascension

           // Setup recipe list listeners dynamically after initial population (delegate pattern)
          DOMElements.recipeList.addEventListener('click', (e) => {
               if (e.target.classList.contains('craft-button')) {
                  const recipeId = e.target.dataset.recipeid;
                   craftItem(recipeId);
               }
          });

          checkAchievements(); // Check on load
          checkSetCompletion(); // Check on load
          checkAscensionUnlock(); // Check ascension state on load

          console.log("Game Initialized.");
          showToast(`Welcome to RNG Collector V4!`, "info", 2000);
       }


       function populateFilterDropdown() { /* Add Has Effect filter */
          const filterSelect = DOMElements.inventoryFilter;
           filterSelect.innerHTML = '<option value="all">All Rarities</option>';
           rarities.forEach(rarity => { if(rarity !== 'Ascended') { /* Hide Ascended for now */ const option = document.createElement('option'); option.value = rarity; option.textContent = rarity; filterSelect.appendChild(option);} });
           filterSelect.innerHTML += '<option value="has_effect">Has Effect</option>'; // Add the new option
       }
      function updateCraftingUI() { /* Alias for clarity */ displayCraftingRecipes(); }


      // --- Start Game ---
      document.addEventListener('DOMContentLoaded', initializeGame);
    </script>
  </body>
</html>
